\subsection{Heaps as Bipartite Graphs}
An important aspect, and a novel contribution, of a symbolic heap is its
representation as a labeled bipartite graph consisting of
references, $\cfgnt{r}$, and constraint location pairs,
$\lp\phi\ \cfgnt{l}\rp$. The heap structure itself captures that the actual
location pointed to by a reference is conditional on aliasing
relationships within the heap. In this way, the graph represents sets
of heaps with the conditions under which those heaps exist.

The graph is expressed in in $\cfgnt{L}$, the location map, and
$\cfgnt{R}$, the reference map. As done with the environment,
$\cfgnt{L}$ and $\cfgnt{R}$ are treated as partial functions where
$\cfgnt{L}(r) = \{(\phi\ \cfgnt{l})\ ...\}$ is the set of
location-constraint pairs in the heap associated with the given
reference, and $\cfgnt{R}(\cfgnt{l},\cfgnt{f}) = \cfgnt{r}$ is the
reference associated with the given location-field pair in the
heap. Predicate calculus is used to describe the more complex updates
to the heap in the semantics.

There are several properties of the heap that are invariant and
important to the correctness.
\begin{compactitem}
\item \textbf{Immutable references}: a reference does not change in
  the location map; it always points to the same set of constraint
  location pairs.
\item \textbf{Reference partitions}: new references are drawn from
  three distinct partitions $\mathrm{init}_r()$, $\mathrm{fresh}_r()$,
  and $\mathrm{stack}_r()$. The references strictly increase in value
  on each call, and modular arithmetic is used to determine the
  partition to which a reference belongs.
\item \textbf{Determinism}: a reference in  $(\cfgnt{L}\ \cfgnt{R})$ cannot point to two locations at the same time.
\[
\begin{array}{l}
\forall \cfgnt{r} \in \cfgnt{L}^\leftarrow\ (\forall (\phi\ \cfgnt{l}),(\phi^\prime\ \cfgnt{l}^\prime) \in \cfgnt{L}(r)\ (\\
\ \ \ \ (\cfgnt{l} \neq \cfgnt{l}^\prime \vee \phi \neq \phi^\prime) \Rightarrow (\phi \wedge \phi^\prime = \cfgt{false}))
\end{array}
\]
$\cfgnt{L}^\leftarrow$ is the pre-image of the location map.
\item \textbf{Type consistent}: every location associated to a reference has the same type.
\[
\begin{array}{l}
\forall \cfgnt{r} \in \cfgnt{L}^\leftarrow\ (\forall (\phi\ \cfgnt{l}),(\phi^\prime\ \cfgnt{l}^\prime) \in \cfgnt{L}(r)\ (\\
\ \ \ \ (\mathrm{Type}\lp\cfgnt{l}\rp = \mathrm{Type}\lp\cfgnt{l}^\prime\rp)))
\end{array}
\]
\item \textbf{Null and Uninitialized}: The location $\cfgnt{l}_\mathit{null}$ is a special location in the
heap to represent null. It has a companion reference
$\cfgnt{r}_\mathit{null}$. The initial heap for the machine is defined
such that $\cfgnt{L}(\cfgnt{r}_\mathit{null}) =
\{(\cfgt{true}\ \cfgnt{l}_\mathit{null})\}$
\end{compactitem}

DEFINE $\rsym$ and $\rgse$.
