\section{Pseudo-code}
\figref{fig:surface-syntax} defines the surface syntax for the
Javalite language \cite{saints-MS}. The \figref{fig:machine-syntax} is
the machine syntax. The semantics of Javalite is syntax based and
defined as rewrites on a string. The semantics use a CEKS machine
model with a (C)ontrol string representing the expression being
evaluated, an (E)nvironment for local variables, a (K)ontinuation for
what is to be executed next, and a (S)tore for the heap. This paper
only defines salient features of the language and machine relevant to
understanding the new algorithm.

\input{surface-syntax}
\input{machine-syntax}

%\item $n$ are numbers, and the set of all positive natural numbers is $\mathbb{N}^+$.
This paper uses a standard definition of constraints $\phi \in \Phi$
assuming all the usual relational operators and connectives. The heap
is a labeled bipartite graph consisting of references $R$ and
locations $L$ in the store. The functions $R$ and $L$ are defined for convenience
in manipulating the labeled bipartite graph.
\begin{itemize}
\item $R(l,f)$ maps location-field pairs from the store to a reference in $R$; and
\item $L(r)$ maps references to a set of location-constraint pairs in the store.
\end{itemize}
A reference is a node that gathers the possible store locations for an
object during symbolic execution. Each store location is guarded by a
constraint that determines the aliasing in the heap. Intuitively, the
reference is a level of indirection between a variable and the store,
and the reference is used to group a set of possible store locations
each predicated on the possible aliasing in the associated constraint.
For a variable (or field) to access any particular store location
associated with its reference, the corresponding constraint must be
satisfied.

\begin{comment}
 defined on value sets $L$ and references
$R$. $R$ and $L$ include the special symbol $\bot$ to indicate an
uninitialized reference and location respectively. Additionally, $L$
includes a special location $\mathtt{NULL}$ for null references.
\end{comment}

Locations are boxes in the graphical representation and indicated with
the letter $l$ in the math. References are circles in the graphical
representation and indicated with the letter $r$ in the math. Edges
from locations are labeled with field names $f \in F$. Edges from the
references are labeled with constraints $\phi \in \Phi$ (we assume
$\Phi$ is a power set over individual constraints and $\phi$ is a set
of constraints for the edge).

The function $\mathbb{VS}(L,R,r,f)$ constructs the value-set given a heap, reference, and desired field.

\begin{eqnarray*}
  	 \{(l^\prime\ \phi\wedge\phi^\prime)\ |\ \exists (l\ \phi)\exists r^\prime \exists(l^\prime\ \phi^\prime) & & \\
                        & & ((l\ \phi) \in L(r) \wedge \\
                        & & r^\prime \in R(l, f) \wedge \\
                        & & (l^\prime\ \phi^\prime) \in L(r^\prime) \wedge\\
                        & & \mathbb{S}(\phi\wedge\phi^\prime))\} 
\end{eqnarray*}

\input{machine-rules}

% Algorithm2e environment
% http://en.wikibooks.org/wiki/LaTeX/Algorithms#Typesetting_using_the_algorithm2e_package
\begin{comment}
\begin{algorithm}
 \SetAlgoLined
 \KwData{this text}
 \KwResult{how to write algorithm with \LaTeX2e }
 initialization\;
 \While{not at end of this document $\wedge x < 2$}{
  read current\;
  \eIf{understand}{
   go to next section\;
   current section becomes this one\;
   }{
   go back to the beginning of current section\;
  }
 }
 \caption{How to write algorithms}
\end{algorithm}
\end{comment}
