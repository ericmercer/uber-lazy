\begin{table} [h]
  \centering
  \begin{tabular}{| c | c | r | r | r | r | }
  \hline
   \multirow{2}{*}{Method }&\multirow{2}{*}{ $k$ }
   &\multicolumn{2}{|c|}{Time} &\multicolumn{2}{|c|}{ Paths }\\
								&	&\gsetxt{}	&SH	&\gsetxt{} & SH\\
   \hline
    \multirow{3}{*}{LinkedList }&3	& 0.91 & 0.69  &1656 & 25		 \\
   		 				& 4	& 2.92 & 0.91	&17485  & 39 \\
   						& 5	& 20.8 & 1.59 &232743 & 56\\
						& 6	& 283 & 2.36		&3731094 & 76\\
    \hline
    \multirow{3}{*}{BinarySearchTree } & 1	&0.26	& 0.36 & 6	 & 6\\
   		 				& 2	& 0.83 & 0.93	& 143 & 33\\
   						& 3	& 20.6 & 4.03 & 515 & 328\\
    \hline
      \multirow{3}{*}{TreeMap}&1	 & 0.47 & 0.77 &11 & 11 \\
   		 				&2	& 8.99 & 4.72	& 127 & 73 \\
   						& 3	& - & 146	& - & 887 \\
						
    \hline
  \end{tabular}
  \caption{test results}
  \label{tab:results}
\end{table}

\subsection{Analysis}

As expected, the repeated use of lazy initialization throughout the program causes an exponential increase in the number of paths explored by \gsetxt{}. By combining many of the \gsetxt{} paths, \symtxt{} avoids the exponential path explosion, demonstrating dramatically reduced, though still exponential, execution time growth. Remarkably, path growth in the k-bound appears to be sub-linear.

While the BinarySearchTree example introduces integer constraints, \symtxt{} performance does not appear to suffer due to the constraint burden. Indeed, at k=3, there appears to be a significant performance advantage in favor of \symtxt{}.

The TreeMap example has a large number of integer compare instructions, and so it should present the greatest challenge to the constraint solver. Despite this, \symtxt{} still explores fewer paths than \gsetxt{}, and \gsetxt{} notably failed to terminate within the allotted time bounds for the $k=3$ test case.



