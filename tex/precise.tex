\section{Generating Symbolic Heap Summaries}
\label{sec:precise}

In this section we present the rules for the $\rsym$ relation. The are
three sets of rewrite rules: the initialization of symbolic
references, the field access and write rules, and finally checking the
equality and inequality of references. Here we describe each of the
rules. They consist the core of the symbolic heap summary approach.

\subsection{Initialization of Symbolic References}

In this section we present the rewrite rules for the initialization of
references in the $\rsym$ relation for a symbolic heap summary. The
initialization rules are defined on the bi-partite graph consisting of
references and locations. In the $\rgse$ relation during
initialization of a symbolic references, it is non-deterministically
assigned to null, new instance of the object, and alias any previously
initialized symbolic reference. In contrast, the heap summarization
approach creates a single branch that contains the summarization for
all the initialization in a single bi-partitate graph.


\input{summarize-precise-incomplete}

\begin{figure*}
\begin{tabular}[c]{l}
\scalebox{1.0}{\usebox{\boxPI}} \\
\end{tabular}
\caption{The summary machine, $s ::= \lp\cfgnt{L}\ \cfgnt{R}\ \cfgnt{r}\ \cfgnt{f}\ \cfgnt{C}\rp$, with $s\rsum^*s^\prime =  s \rsum \cdots \rsum s^\prime \rsum s^\prime$.}
\label{fig:symInit}
\end{figure*}

The initialization rules are invoked when an uninitialized field in a
symbolic reference is accessed. The function $\mathbb{UN}(\cfgnt{L},
\cfgnt{R}, \cfgnt{r}, \cfgnt{f}) = \{\cfgnt{l}\ ...\}$ returns
constraint-location pairs in which the field $\cfgnt{f}$ is
uninitialized:
\[
\begin{array}{rcl}
\mathbb{UN}(\cfgnt{L}, \cfgnt{R}, \cfgnt{r}, \cfgnt{f}) & = &\{ \lp\phi\ \cfgnt{l}\rp \mid \lp \phi\ \cfgnt{l}\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp  \wedge \\
& & \ \ \ \ \exists \phi^\prime \lp \lp \phi^\prime\ \cfgnt{l}_\mathit{un}\rp  \in \cfgnt{L}\lp \cfgnt{R}\lp l,\cfgnt{f}\rp\rp \wedge \\
& & \ \ \ \ \ \ \ \ \mathbb{S}\lp \phi \wedge \phi^\prime \rp\rp\}\\
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is
satisfiable. Intutively, for the reference, $\cfgnt{r}$, it constructs
the set, $\theta$, that contains all contraint-location pairs that
point to the field $\cfgnt{f}$ and $\cfgnt{f}$ points to
$\cfgnt{l}_\mathit{un}$.

% The cardinality of the set, $\theta$ is never
%greater than one in GSE and the constraint is always satisfiable
%because all constraints are constant. This property is relaxed in GSE
%with heap summaries.

The rewrite rule to initialize a heap in the symbolic summarization
technique is shown in~\figref{fig:symInit}. Given the unitialized set
$\mathbb{UN}$ for field $f$, the $\mathit{min}_l$ function returns
$(\phi_x, l_x)$ based on a lexical ordering of uninitialized locations
in $\Lambda$. The init$_r$ method returns a new input reference $r_f$
while the fresh$_f$ returns a new location of type $C$. The set $\rho$
contains the set of reference location pairs, $(r_a, l_a)$, that the
field being initialized may alias. The pair $(r_a, l_a)$ is contained
in the set $ \rho $ if the following conditions hold: (i) $r_a$ is
part of the input references initialized in the summary heap, (ii)
$r_a$ is in the pre-image of $l_a$, (iii) and the type of $l_a$ is the
same as the type of the field being initialized.

There are three constraint-location pair sets that correspond to
non-deterministic choices in GSE: (a) $\theta_\mathit{null}$ contains
a constraint $r_f = r_\mathit{null}$ paired with the location
$l_\mathit{null}$, (b) $\theta_\mathit{new}$ creates a pair with the
constraint $r_f$ is not null and it does not alias any reference in
set $\rho$ under and a newly created location $l_f$, (c) and
$\theta_\mathit{alias}$ where for each element in the set $(r_a, l_a)
\in \rho$ it creates a constraints that $r_f$ is not null, points to
$r_a$, and does not point to any reference contained in $(r_a^\prime,
l_a^\prime) \in \rho$ such that $r_a < r_a^\prime$ based on a lexical
ordering of initialized references. Additionally
$\theta_\mathit{orig}$ allows for the possibility that the field
continues to remain uninitialized since the heap is symbolic. We refer
to this initialization in the summary machine as conditional
initialization. Finally, the fields of the reference $r_f$ are marked
as uninitialized. In the post condition of the rule the reference
$r_f$ points to $\theta$ which contains the union of all the
constraint location pairs sets, and the field $f$ points to the new
reference $r_f$ in the summary heap.

\begin{comment}
 Note that the summarize rule invoked repeatedly until
the set of unitialized constraint location pairs for field $f$ is
empty. In other words the set $\Lambda$ is empty. This consititutes
the summarize end rule in~\figref{fig:symInit}.
\end{comment}

\begin{figure*}[t]
\begin{center}
\begin{tabular}[c]{c|c|c|c}
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{origHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{summarizeXHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{summarizeYHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{l}
$\rho := \{ (r_1^i, l_1 \}$ \\
$\theta_\mathit{null} := \{ ( r_2^i = r_\mathit{null}, l_\mathit{null}) \}$\\
$\theta_\mathit{new} := \{ ( r_2^i \neq r_\mathit{null} \wedge r_2^i \neq r_1^i, l_2) \}$\\
$\theta_\mathit{alias} := \{ ( r_1^i \neq r_\mathit{null} \wedge r_2^i \neq r_\mathit{null} \wedge r_2^i = r_1^i, l_1) \}$\\
$\theta_\mathit{orig} := \{ \}$ \\
$\phi_{\mathit{1a}} := r_1^i = r_\mathit{null} $ \\
$\phi_{\mathit{1b}} := r_1^i \neq r_\mathit{null} $  \\
$\phi_{\mathit{2a}} := r_2^i = r_\mathit{null}$ \\
$\phi_{\mathit{2b}} := r_2^i \neq r_\mathit{null} \wedge r_2^i \neq r_1^i$ \\
$\phi_{\mathit{2c}} :=  r_2^i \neq r_\mathit{null} \wedge r_2^i = r_1^i $ \\
\end{tabular} \\
(a) & (b) & (c) & (d) \\
\end{tabular}
\end{center}
\caption{initialize this.x and this.y}
\label{fig:initHeap}
\end{figure*}

We visualize the initialization process in~\figref{fig:initHeap}. The
graph in~\figref{fig:initHeap}(a) represents the initial heap. The
references with the superscript $s$ indicates that it is a local
reference. In~\figref{fig:initHeap} $r_0^s$ represents a local
reference for the $\mathit{this}$ reference which has two fields $x$
and $y$ of the same type; reference $r_0^s$ points to location
$l_0$. Note that when no constraint is specified in the graphs, then
there is a implicit $\mathit{true}$ constraint, for example, $r_0^s$
points to $l_0$ on the constraint $\mathit{true}$. The fields $x$ and
$y$ point to the uninitialized reference $r_\mathit{un}$.

% The reference $r_\mathit{un}$ points to the uninitialized location
%$l_\mathit{un}$ on the $\mathit{true}$ constraint.

The graph in~\figref{fig:initHeap}(b) represents the symbolic heap
summary after the initialization of the $\mathit{this}.x$ field while
the graph in~\figref{fig:initHeap}(c) represents the symbolic heap
summary after the initialization of the $\mathit{this}.y$ field
following the initialization of $\mathit{this}.x$. The list
in~\figref{fig:initHeap}(d) represents the various sets constructed in
the summarize rule during the initialization of $\mathit{this}.y$. We
also define values of constraints used as labels in the graph.

The access on $l_0.x$ creates a new input reference $r_1^i$ in the
summary heap shown in~\figref{fig:initHeap}(b). The reference $r_1^1$
points to the $l_\mathit{null}$ location under the constraint that
$r_1^i$ is null: $\phi_{1a} := r_1^i = r_\mathit{null}$. The reference
$r_1^i$ points to the location $l_1$ under the constraint that $r_1^i$
is not $\mathit{null}$ $\phi_{1b} :=r_1^i \neq r_\mathit{null}$. The
location $l_1$ represents a fresh location of type $C$ is created on
the heap such that $C$ is type of $\mathit{this}.x$.

Following the initialization to the $\mathit{this}.x$, when we
initialize $\mathit{this}.y$ the resulting summary heap is shown
in~\figref{fig:initHeap}(c). The set $\rho$ shown
in~\figref{fig:initHeap}(d) contains the potential aliases for
$\mathit{this}.y$ which is location $l_1$ ($\mathit{this}.x$). The
constraint location $\theta$ sets represents the initialization
choices for $\mathit{this}.y$. The new input reference $r_2^i$ for
$this.y$ points to (a) location $l_\mathit{null}$ under the constraint
$\phi_{2a} := r_2^i = r_\mathit{null}$, (b) location $l_2$ under the
constraint $\phi_{2b} := r_2^i \neq r_\mathit{null} \wedge r_2^i \neq
r_1^i$ that states that $r_2^i$ is not null and does not alias
$r_1^i$, and (c) location $l_1$ under the constraint $\phi_{2c} :=
r_2^i \neq r_\mathit{null} \wedge r_2^i = r_1^i$ that states $r_2^i$
is not null and \emph{does} alias $r_1^i$.


\subsection{Reading and Writing References}
\input{precise-fig-incomplete}

\begin{figure*}[t]
\begin{center}
\setlength{\tabcolsep}{60pt}
\hspace*{-35pt}
\begin{tabular}[c]{cc}
\scalebox{1.0}{\usebox{\boxPFAFW}} & 
%\scalebox{0.91}{\input{faYHeap.pdf_t}} &
\scalebox{0.91}{\input{fwXHeap.pdf_t}} \\ \\
(a) & (b)
\end{tabular}
\end{center}
\caption{field access for this.y and field write for this.x = this.y}
\label{fig:fHeap}
\end{figure*}

There are two rewrite rules in~\figref{fig:fHeap}(a), one for reading
the value of a field (field-access) and the other when we write to a
field (field-write). In both the field rewrite rules we first check we
perform is whether there exists a constraint location pair for the $r$
being accessed such that the location is not null and the constraint
when conjuncted with the global constraint is satisfiable. Next we
extract all possible constraints under which $r$ points to a null
location such that the constraint is satisfiable under the current
global constraint, $\phi_g$. The negation of these constraints are
added to the global constraint to create a new global constraint
$\phi_g^\prime$. The update to the global constraint ensures that
access or write of the field $f$ happens only on non-null
locations. There are rewrite rules for accessing and writing to fields
on null locations where it leads the current program execution state
to an error state. The rewrite rules for the accessing and writing to
null locations are presented in the supplemental document.

In the field-access rewrite rule in~\figref{fig:fHeap}(a) after the
non-nullness check we extract the The type $C$ of the field is
extracted and invoke the summarize rewrite rule
in~\figref{fig:symInit} that performs the initialization of the field
if it points to uninitialized locations. Once the initialization is
complete, we create a new local reference $r^\prime$. An important
property of the references in the bi-partiate graph is that they are
\emph{immutable}. Hence we create a new local reference and assign it
to the initialized reference, and return the local reference. In order
to de-reference a field $r.f$ we define a helper function which is
called the value set.

\input{value-set-def}

In the post-condition of the rewrite rule we assign
the value set of input reference $r$ to the local reference $r^\prime$
and return the local reference $r^\prime$ in the next state.

Consider the graph shown in~\figref{fig:fHeap}(b) the reference
$r_2^i$ is created during the initialization of $\mathit{this}.y$. The
reference that is returned during the access of the field, however, is
$r_3^s$. The reference $r_3^s$ points to the value set of $r_2^i$
which are: $(\phi_{2a}, l_\mathit{null})$, $(\phi_{2b}, l_2)$, and
$(\phi_{2c}, l_1)$. The values of the constraints $\phi_{2a}$,
$\phi_{2b}$, and $\phi_{2c}$ are defined in~\figref{fig:initHeap}(d).

The field-write rewrite rule in~\figref{fig:fHeap}(a) after the
non-nullness check we We look up the value of the base reference in
the environment $\eta(x)$.  The reference $r_x$ is the base pointer
whose field, $r_\mathit{curr}$ is being written to to while the
reference $r$ is the target reference. The set $\Psi_x$ contains
tuples $(\phi l r_\mathit{curr})$ of constraints, locations, and
references. These tuples represent access chains leading from $r_x$ to
the reference of the field, $r_\mathit{curr}$. The goal is to
overwrite the $r_\mathit{curr}$ references with the target
references. Since the target of the write is $r$, we first check that
the location constraint pairs of $L(r)$ are satisfiable when accessed
through the $r_x$ chain. This is accomplished by the strengthening
function.

\input{st-def}

Note that the write is conditional. In the case that $\phi$ is true
then $r_\mathit{curr}$ will point to the constraint location pairs of
$L(r)$ while if $\phi$ is false then $r_\mathit{curr}$ will continue
to point to the constraint location pair it is currently pointing to.
Again since the references are immutable we create a new reference for
each $r_\mathit{curr}$ and point them to the target constraint
location pairs.

Consider the example shown in~\figref{fig:fHeap}(b) where we assign
$\mathit{this}.x := \mathit{this}.y$. Note that
in~\figref{fig:initHeap}(c) $\mathit{this}.x$ is represented by
$r_1^i$. After applying the field-write rule the reference $r_1^i$ is
replaced by the fresh reference $r_4$ which now points to target
$\mathit{this}.y$ represented by $L(r_2^i)$.


\begin{comment}
\begin{figure}[t]
\begin{center}
\begin{tabular}[c]{l}
$\Psi_x = \{ (true, l_0, r_1^i) \}$\\
$ST (L, r_3^s, \phi, \phi_g)$ \\
$\theta = \{ (\phi_{2a}\; l_\mathit{null} ) (\phi_{2b}\; l_2) (\phi_{2c}\; l_1) \}$\\
$ST(L, r_0, \phi, \phi_g)$\\
$\theta = \{ \}$\\
\end{tabular}
\end{center}
\caption{FIXME: When will I get a caption}
\label{fig:faHeapSets}
\end{figure}
\end{comment}



\subsection{Equality and InEquality of References}
\input{precise-eq}

\begin{figure*}
\begin{center}
\begin{tabular}[c]{c}
\scalebox{1.0}{\usebox{\boxPEQ}} \\
% & \usebox{\boxPEX} \\ \\
%(a) & (b) \\
\end{tabular}
\end{center}
\caption{FIXME: I desperately need a caption!}
\label{fig:eqs}
\end{figure*}



\newsavebox{\boxPEX}
\savebox{\boxPEX}{
\begin{tabular}[c]{l}
$L(r_1^i) = \{ (\phi_{1a}\; l_\mathit{null})\; (\phi_{1b}\; l_1) \}$ \\
$L(r_2^i) = \{ (\phi_{2a}\; l_\mathit{null}),\; (\phi_{2b}\; l_2),\; (\phi_{2c}\; l_1) \} $\\
  $\theta_0 = \{ \} $\\
$\theta_1 = \{ \phi_{2b}\} $\\ \hline
Equals true \\
$\theta_\alpha = \{ (\phi_{1a}\; \wedge\; \phi_{2a} ) (\phi_{1b}\; \wedge\; \phi_{2c} ) \}$\\
$\phi^\prime = \mathit{true} \wedge [ (\phi_{1a}\; \wedge\; \phi_{2a} )\vee (\phi_{1b}\; \wedge\; \phi_{2c} ) ] \wedge \neg\phi_{2b} $\\ \hline
Equals false \\
$\theta_\alpha = \{ (\phi_{1a}\; \implies\; \neg\phi_{2a} ) (\phi_{1b}\; \implies\; \neg\phi_{2c} ) \}$\\
$\phi^\prime = \mathit{true} \wedge  (\phi_{1a}\; \implies\; \neg\phi_{2a} )\wedge (\phi_{1b}\; \implies\; \neg\phi_{2c} )  \wedge \phi_{2b} $\\ \hline
\end{tabular}}


The rewrite rules to compare two references in the symbolic summary
heap are shown in~\figref{fig:eqs}. The equals references-true rewrite
rule returns true when two references $r_0$ and $r_1$ \emph{can} be
equal. In GSE semantics checking equality of references is a simple
comparision of two concrete object references. In the symbolic summary
heap, however, we compare sets of constraint location pairs pointed to
by each reference to determine if they could be equal. 

Consider the equals reference-true rewrite rule
in~\figref{fig:eqs}. In order to check equality we construct three
sets of constraints. For all constraint location pairs $(\phi_0, l_0)
\in L(r_0)$ and $(\phi_1, l_1) \in L(r_1)$ such that $l_0$ and $l_1$
are the same ($l_0 = l_1$) we create conjunctions of the constraints
$\phi_0 \wedge \phi_1$ and add them to set $\Phi_\alpha$. Intutively,
$\Phi_\alpha$ contains all constraints under which $r_0$ and $r_1$ may
point to the same location in the symbolic summary heap. The second
set, $\Phi_0$, contains constraints under which the reference $r_0$
points corresponding locations such that the reference $r_1$
\emph{does not} point to those locations under any
constraint. Finally, the set, $\Phi_1$, contains constraints under
which $r_1$ points to corresponding locations and $r_0$ \emph{does
  not} point to those locations under any constraint.

We use the three sets of constraints to update the current global heap
constraint $\phi_g$ and create a new global heap constraint
$\phi_g^\prime$. We add to $\phi_g$ the disjunction of the constraints
in $\Phi_\alpha$ to indicate that if any of the constraints are
satisfiable, then references $r_0$ and $r_1$ can be
equal. Furthermore, we had to the global heap constraint,
$\phi_g^\prime$, the conjunctions of negations to the constraints in
$\Phi_0$ and $\Phi_1$. This indicates for locations that are not
common to the references, the negations of their constraints are
satisfiable. Before the rewrite rule returns true we check the
satisfiability of the updated global heap constraint.

Consider the example in~\figref{fig:initHeap}(c). In order to to check
if $r_1^i$ and $r_2^i$ are equal we first get the constraint location
pairs associated with each of the references:

\[
L(r_1^i) = \{ (\phi_{1a}\; l_\mathit{null})\; (\phi_{1b}\; l_1) \} 
\]
\[
L(r_2^i) = \{ (\phi_{2a}\; l_\mathit{null}),\; (\phi_{2b}\; l_2),\; (\phi_{2c}\; l_1) \} \\
\]

\noindent{The three constraint sets are:} 

\[
\Phi_\alpha = \{ (\phi_{1a}\; \wedge\; \phi_{2a} ) (\phi_{1b}\; \wedge\; \phi_{2c} ) \}\;
\Phi_0 = \{ \}\; \Phi_1 = \{ \phi_{2b}\} \\
\]

\noindent{Finally the global constraint is} 
\[
\phi^\prime = \mathit{true} \wedge [ (\phi_{1a}\; \wedge\; \phi_{2a} )\vee (\phi_{1b}\; \wedge\; \phi_{2c} ) ] \wedge \neg\phi_{2b} 
\]

\noindent{The equals references-false is the logical dual of the
  reference-true rewrite rule. The references-false is shown
  in~\figref{fig:eqs}.}
