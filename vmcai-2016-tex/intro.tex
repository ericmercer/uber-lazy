\section{Introduction}




%In recent years symbolic execution has provided the basis for various
%software testing and analysis techniques, e.g., regression
%analysis~\cite{backes:2012,Godefroid:SAS11,Person:FSE08,person:pldi2011,Ramos:2011,Yang:ISSTA12},
%data structure repair~\cite{KhurshidETAL05RepairingStructurally},
%dynamic discovery of
%invariants~\cite{CsallnerETAL08DySy,Zhang:ISSTA14}, and
%debugging~\cite{Ma:2011}.
%
%Recent work has explored the strengths and limitations of
%tools which leverage constraint solvers, e.g., concolic execution,
%identifying symbolic dereferencing and updating operations as areas
%for potential improvement~\cite{Chen:2013,Qu:2011}.  

In symbolic execution, the values of program variables are represented
as constraints over the program's inputs. During the course of an
execution, a program variable may assume a number of possible values
under a variety of different conditions. One way to represent this
behavior is by pairing each possible value with the constraints under
which it is assumed. A set of such value-constraint pairs, called a
\emph{guarded value set}\footnote{Guarded value sets are variously
  referred to in the literature as \emph{guarded location sets},
  \emph{symbolic value sets}, or \emph{value summaries}. The term
  guarded value set is sometimes abbreviated in this text
  as~\emph{value set}.}, represents the state of a program variable.

Guarded value sets are rising in importance in the representation of
reference values. First appearing in Verification-Condition Generator
(VCG) style techniques~\cite{Xie:2005,Dillig:2011}, guarded value sets
are a convenient way to represent sets of heap shapes. More recently,
guarded value sets are being used in symbolic execution for the
purposes of modularization~\cite{Yorsh:2008}, state
merging~\cite{Sen:2014}, and for determining
invariants~\cite{Ferrara:2014,Torlak:2014}.

A common hurdle to using guarded value sets is the treatment of
symbolic heap inputs. For many applications, it is desirable to model
the input heap as unconstrained, with operations over the input
references providing the only means of divining its
structure. Precisely modeling operations on unconstrained heap inputs
is challenging because it requires formulating logical predicates over
an input domain that contains a potentially unbounded number of hidden
references~\cite{Chen:2013,Qu:2011}. Generalized symbolic execution
(\gsetxt{}) methods~\cite{GSE03,Deng:2007} provide an accurate
solution, but they quickly produce an overwhelming number of execution
paths for all but the simplest heap shapes. Efforts to
extend~\gsetxt{} principles to guarded value sets have failed to
produce provably equivalent results \cite{LISTEFFORTS}. Thus, despite
the advantages of using guarded value sets, it remains an open
question how they can be used in symbolic execution to automatically
model all possible program behaviors in the case of an arbitrary input
heap.

The contribution of this work is a symbolic initialization scheme for
uninitialized references in a fully symbolic heap. Where GSE lazily
instantiates uninitialized references to either NULL, a new instance
of the correct type, or an alias to a previously initialized object,
the symbolic initialization in this work creates a guarded value set
expressing all of these eventualities in the same symbolic heap. Where
GSE branches the search space on each choice, symbolic initialization
does not. Symbolic initialization only branches on reference compares,
partitioning the symbolic heap to indicate heaps where the references
alias and heaps where the references do not.

This paper includes a proof that symbolic initialization is sound and
complete with respect to properties provable by GSE. Such a result is
important because it means that symbolic initialization can be used to
create test inputs for other analyses in a way that is provably
correct with regards to GSE: there are no missing heaps and there are
no extra heaps.

A proof-of-concept implementation of symbolic initialization is
reported in this paper. The implementation is for Java in the Java
Pathfinder tool. It demonstrates the efficiency of~\symtxt{}, as
compared to existing~\gsetxt{} methods. The use of the guarded value
sets does require extra interaction with an SMT solver, but the
savings in representing multiple heap shapes in a single
representation overcomes the cost of the solver calls. In fact, the
comparison shows an exponential increase in the number of heaps that
can be analyzed in a set of benchmark examples meaning that other
approaches based on~\gsetxt\ fail to complete.

