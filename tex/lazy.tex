\section{Generalized Symbolic Execution with Lazy Initialization}

The function $\mathbb{VS}(L,R,\phi_g,r,f)$ constructs the value-set given a
heap, reference, and desired field:
\[
\begin{array}{rcl}
  \mathbb{VS}(L,R,\phi_g,r,f) & = & \{(\phi\wedge\phi^\prime\ l^\prime) \mid \\
  & & \ \ \ \ \exists l\ ((l\ \phi) \in L(r)\ \wedge \\
  & & \ \ \ \ \ \ \ \ \exists r^\prime \in R(l,f) ( \\
  & & \ \ \ \ \ \ \ \ \ \ \ \ (l^\prime\ \phi^\prime) \in L(r^\prime)\ \wedge\\
  & & \ \ \ \ \ \ \ \ \ \ \ \ \mathbb{S}(\phi\wedge\phi^\prime\wedge \phi_g)))\}
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is satisfiable.

The strengthen function $\mathbb{ST}(L,r,\phi^\prime)$ strengthens every
constraint from the reference $r$ with $\phi^\prime$ and keeps only location-constraint
pairs that are satisfiable after this strengthening:
\[
\begin{array}{rcl} 
\mathbb{ST}(L,r,\phi) & = & \{ (\phi\wedge\phi^\prime\ l) \mid 
(\phi^\prime\ l)\in L(r)\wedge\mathbb{S}(\phi\wedge\phi^\prime\wedge\phi_g) \}
\end{array}
\]

\input{initialize-lazy}
\input{lazy-fig}

\begin{comment}
NOT SURE THIS NEEDS TO BE HERE ANYMORE
Generalized symbolic execution with lazy initialization is a technique
to apply symbolic execution to non-primitive data types (i.e.,
objects) \cite{GSE03}. The approach initializes each symbolic object
to be either null, a new instance of the object, or an alias to an
object previously created as part of lazy initialization. Each of
these outcomes is a possible choice, and a model checker is able to
exhaustively enumerates these choices effectively creating all
possible concrete heaps under the choice sets. The approach is first
formalized in this section and then extended to describe the precise
heap summaries.


Many of these concrete
heaps explore redundant control flow paths in the program under test,
but since symbolic model checking is stateless, subject to a bound to
terminate the search, the model checker needlessly explores many
redundant state leading to severe state explosion.

A reference is a node that gathers the possible store locations for an
object during symbolic execution. Each store location is guarded by a
constraint that sets the conditions under which the edge is valid. Intuitively, the
reference is a level of indirection between a variable and the store,
and the reference is used to group a set of possible store locations
each predicated on the possible aliasing in the associated constraint.
For a variable (or field) to access any particular store location
associated with its reference, the corresponding constraint must be
satisfied.

Locations are boxes in the graphical representation and indicated with
the letter $l$ in the math. References are circles in the graphical
representation and indicated with the letter $\cfgnt{r}$ in the
math. The special symbol $\bot$ is an uninitialized reference. Edges
from locations are labeled with field names $\cfgnt{f}$. Edges from
the references are labeled with constraints $\phi \in \Phi$ (it is
assumed that $\Phi$ is a power set over individual constraints and
$\phi$ is a set of constraints for the edge).
\end{comment}
