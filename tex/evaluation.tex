
\begin{table} [h]
  \centering
  \begin{tabular}{| c | c | c | c | c | c | c | c |}
  \hline
   \multirow{2}{*}{Method }&\multirow{2}{*}{ $k$ }
   &\multicolumn{2}{|c|}{Time} &\multicolumn{2}{|c|}{ Paths }\\
								&	&\gsetxt{}	&SH	&\gsetxt{} & SH\\
   \hline
    \multirow{3}{*}{LinkedList }&3	& 0.91 & 0.69  &1656 & 25		 \\
   		 				& 4	& 2.92 & 0.91	&17485  & 39 \\
   						& 5	& 20.8 & 1.59 &232743 & 56\\
						& 6	& 283 & 2.36		&3731094 & 76\\
    \hline
    \multirow{3}{*}{BinarySearchTree } & 1	&0.26	& 0.36 & 6	 & 6\\
   		 				& 2	& 0.83 & 0.93	& 143 & 33\\
   						& 3	& 20.6 & 4.03 & 515 & 328\\
    \hline
      \multirow{3}{*}{TreeMap}&1	& 0 & 0.47 	& 0.77 & 11 \\
   		 				&2	& 8.99 & 4.72	& 127 & 73 \\
   						& 3	& - & 146	& - & 887 \\
						
    \hline
  \end{tabular}
  \caption{test results}
  \label{tab:results}
\end{table}

\subsection{Analysis}

LinkedList
As expected, the repeated use of lazy initialization throughout the program causes an exponential increase in the number of paths explored by \gsetxt{}. By combining many of the \gsetxt{} paths, SH avoids the exponential path explosion, demonstrating dramatically reduced, though still exponential, execution time growth. Remarkably, path growth in the k-bound appears to be sub-linear.

The BinarySearchTree example is somewhat of a mixed bag. 

TreeMap

