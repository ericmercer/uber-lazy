\section{Pseudo-code}
\figref{fig:surface-syntax} defines the surface syntax for the
Javalite language \cite{saints-MS}. The \figref{fig:machine-syntax} is
the machine syntax. The semantics of Javalite is syntax based and
defined as rewrites on a string. The semantics use a CEKS machine
model with a (C)ontrol string representing the expression being
evaluated, an (E)nvironment for local variables, a (K)ontinuation for
what is to be executed next, and a (S)tore for the heap. This paper
only defines salient features of the language and machine relevant to
understanding the new algorithm.

\input{surface-syntax}
\input{machine-syntax}

%\item $n$ are numbers, and the set of all positive natural numbers is $\mathbb{N}^+$.
\begin{itemize}
\item $x \in X$ is a variable
\item $f\in F$ is a field name in an object
\item $r\in V$ is a reference
\item $e$ is an expression.
  \begin{itemize}
  \item $v$
  \item $x$
  \item $(e\ \$\ f)$
  \item $(x\ := e)$
  \item
  \end{itemize} Expressions can be values $v$, sequencing
  ($(begin\ e\ \ldots)$), field access ($(x.f)$ or $(x.f := e)$), and
  other constructs to be defined soon,...
\item $\mu$ is the text that defines classes and methods.
\item $P$ is a program $(\mu, (C m))$ where $C$ is a class defined in
  $\mu$ and $m$ is a method in that class.
\item $(L,R)$ represent the heap and form a bipartite graph (see below).
\item $\eta : X \rightarrow V$ is an environment
\item $k$ is a continuation to resolve evaluation order and return points from calls
\begin{itemize}
\item $\mathtt{end}$: nothing comes next
\item $(*\ \$\ f \rightarrow k)$: access field $f$ once expression is reduced to a reference.
\end{itemize}
\item $s = (\mu\ h\ \eta\ e\ k)$ is a machine state.
\item $(\mu\ h^\prime\ \eta^\prime\ e^\prime\ k^\prime) =
  \mathrm{execute}(\mu, h, \eta, e, k)$ is a function that returns a
  state by evaluating the expression.
\end{itemize}

The heap is a bipartite graph defined on locations $L$ and references
$R$. $R$ and $L$ include the special symbol $\bot$ to indicate an
uninitialized reference and location respectively. Additionally, $L$
includes a special location $\mathtt{NULL}$ for null references.

Locations are boxes in the graphical representation and indicated with
the letter $l$ in the math. References are circles in the graphical
representation and indicated with the letter $r$ in the math. Edges
from locations are labeled with field names $f \in F$. Edges from the
references are labeled with constraints $\phi \in \Phi$ (we assume
$\Phi$ is a power set over individual constraints and $phi$ is a set
of constraints for the edge).

The heap is now defined
as $h = (L\ R\ \mathit{ref}\ \mathit{loc})$ where
\begin{itemize}
\item $\mathit{ref} : L \times F \mapsto R$ is the
  connection between locations and references on a named field. The
  function can also be viewed as a set $\mathit{ref} \subseteq L
  \times F \times R$ in a set if that is preferred to a function.
\item $\mathit{loc} : R \mapsto 2^{L \times \Phi}$ is the connection
  between a reference and a location on a constraint. The function
  $\mathit{loc}$ can also be viewed as a set $\mathit{loc} \subseteq R
  \times \Phi \times L$.
\end{itemize}

\input{machine-rules}



% Algorithm2e environment
% http://en.wikibooks.org/wiki/LaTeX/Algorithms#Typesetting_using_the_algorithm2e_package
\begin{comment}
\begin{algorithm}
 \SetAlgoLined
 \KwData{this text}
 \KwResult{how to write algorithm with \LaTeX2e }
 initialization\;
 \While{not at end of this document $\wedge x < 2$}{
  read current\;
  \eIf{understand}{
   go to next section\;
   current section becomes this one\;
   }{
   go back to the beginning of current section\;
  }
 }
 \caption{How to write algorithms}
\end{algorithm}
\end{comment}
