\section{Related Work}
\label{related}

\subsection{Symbolic Exection}
Generalized symbolic execution \cite{GSE03} was the first symbolic execution method to handle linked data structures as inputs. Subsequent improvements to the method \cite{Deng:2006,Deng:2007} reduce path explosion by delaying path splitting over aliasing choices for as long as possible. However, since all of the above methods introduce nondeterminism during field reads and writes, they all worsen the path explosion problem to some extent or another. Since our heap representation does not introduce any nondeterminism beyond the level in standard symbolic execution, it will generally create fewer paths than these methods, sometimes by a wide margin.

\subsection{Model Checking}
Need to talk about Bounded Model Checking, etc.

\subsection{Static Analysis}
A number of static analysis techniques have been proposed that have some ability to reason about input heap structures. These techniques are usually over-approximations, often have difficulty reasoning about path-sensitive properties, or cannot reason about programs with recursive data structures. Moreover, static analysis methods are seldom useful for test-case generation.

One notable static analysis method that is closely related to ours is the procedure summaries proposed by Isil and Tomas Dillig \cite{Dillig:2011}. Elements of their technique that are similar to ours include; references guarded by constraint expressions, conditional write semantics, and a general aversion to path splitting. However, their method is limited by most of the standard problems with static analysis techniques, including path sensitivity, imprecision, and recursive data structures. While their method has improved path sensitivity over standard static analysis methods, it remains limited by a statically-generated symbolic input heap, and cannot adapt to path-sensitive heap properties of the input heap. Thus, their method cannot determine a priori which nodes in the input heap are actually accessed by the program. It may potentially generate input heaps containing a significant number of nodes that have no impact on program execution.

\subsection{Heap Representations}
A number of other techniques model references using sets of guarded locations \cite{Xie:2005,Cherem:2007,Dillig:2011}. These sets, sometimes known as value sets or value summaries, allow multiple heaps to be represented simultaneously with a higher degree of precision than afforded by shape analysis. However, some of these previous attempts utilize non-local recursive definitions for objects. The impact of using recursive definitions for objects is two-fold. First, these techniques must use approximations to resolve reference inequalities, resulting in false positives in the results. Second, these techniques are incapable of reasoning about heaps with loops in the data structures due to infinite recursion during dereferencing. This means that either a large class of data structures must be avoided, or a large class of behaviors must be ignored. In our heap representation, object descriptions are entirely local, thus avoiding these pitfalls.