
\begin{figure*}[t]
\begin{center}
\mprset{flushleft}
\begin{mathpar}
	\inferrule[Variable lookup]{}{
      (L\ R\ \eta\ \mathrm{x}\ k) \rightarrow (L\ R\ \eta\ \eta(\mathrm{x})\ k)
	}
\and
	\inferrule[Field Access(eval)]{}{
      (L\ R\ \eta\ (e\ \$\ \mathrm{f})\ k) \rightarrow (L\ R\ \eta\ e\ (*\ \$\ \mathrm{f} \rightarrow k))
	}
\and
	\inferrule[Field Access (NULL)]{
      L(r) = \emptyset
    }{
      (L\ R\ \eta\ r\ (*\ \$\ \mathrm{f} \rightarrow k)) \rightarrow 
      (L[r \mapsto \{(\bot,\top)\}]\ R\ \eta\ r\ (*\ \$\ \mathrm{f} \rightarrow k))
	}
\and
	\inferrule[Field Access (non-NULL)]{
      L(r) = \emptyset \\
      \mathrm{type}(r) = \mathrm{C}_r\\
      \mathrm{fresh}_l(\mathrm{C}_r) = l \\\\
      R^\prime = R[\forall \mathrm{f} \in \mathrm{C}\ ((l\ \mathrm{f}) \mapsto \mathit{fresh_r}(\mathit{type}(\mathrm{f})))]
    }{
      (L\ R\ \eta\ r\ (*\ \$\ \mathrm{f} \rightarrow k)) \rightarrow 
      (L[r \mapsto \{(l,\top)\}]\ R^\prime\ \eta\ r\ (*\ \$\ \mathrm{f} \rightarrow k))
	}
\and
	\inferrule[Field Access]{
      h(r) \neq \emptyset \\
      \mathrm{type}(r) = C \\
      \mathrm{fresh}_r(C) = r_f \\\\
      Q = \{(r^\prime\ \phi)\ |\ (l\ \phi) \in L(r) \wedge r^\prime \in R(l\ \mathrm{f})\} \\\\
      L_f = L[r_f \mapsto \cup_{(r^\prime\ \phi)\in Q} \{(l\ \phi^\prime\phi)\ |\ (l\ \phi^\prime) \in L(r^\prime)\}]
    }{
      (L\ R\ \eta\ r\ (*\ \$\ \mathrm{f} \rightarrow k)) \rightarrow 
      (L_f\ R\ \eta\ r_f\ k)
	}
\end{mathpar}
\end{center}
\caption{Uber-lazy state reductions}
\label{fig:expr:red}
\end{figure*}


%% Expression syntax

\begin{comment}
\begin{figure}[ht]
\begin{center}
\cfgstart

\cfgrule{estate}{($\sigma$ $\eta$ \cfgnt{e} \cfgnt{k})}

\cfgrule{$\sigma$}{$\emptyset$ \cfgor \lp $\sigma$ \cfgq{[}
  \cfgnt{address} \cfgq{$\mapsto$} \cfgnt{v} \cfgq{]}\rp }

\cfgrule{$\eta$}{$\emptyset$ \cfgor \lp $\eta$ \cfgq{[} \cfgnt{id}
  \cfgq{$\mapsto$} \cfgnt{v} \cfgq{]}\rp }

\cfgrule{ae}{\cfgnt{v} \cfgor \cfgnt{id}}	
\cfgrule{e}{\cfgnt{ae} \cfgor \lp\cfgq{@} \cfgnt{e}\rp}
	\cfgorline{\lp\cfgnt{setop} \lp\cfgnt{pattern} \cfgq{in} \cfgnt{e}\rp ~\cfgnt{e}\rp}
	\cfgorline{\lp\cfgq{if} \cfgnt{e} \cfgnt{e} \cfgnt{e}\rp}
	\cfgorline{\lp\cfgq{let} \lp\cfgq{[}\cfgnt{id} \cfgnt{e}\cfgq{]}\rp ~\cfgnt{e}\rp}
	\cfgorline{\lp \cfgnt{op} \cfgnt{e} \cfgnt{e} ...\rp}
\cfgrule{v}{\cfgt{number}}
	\cfgorline{\cfgq{true} \cfgor \cfgq{false}}
	\cfgorline{\cfgq{error}}
	\cfgorline{\cfgt{string}}
	\cfgorline{\lp\cfgq{addr} \cfgnt{address}\rp}
	\cfgorline{\lp\cfgq{const-set} \cfgnt{v} ...\rp}
	\cfgorline{\lp\cfgq{const-tuple} \cfgnt{v} ...\rp}
\cfgrule{pattern}{\cfgnt{id} \cfgor \lp\cfgq{tuple} \cfgnt{id} ...\rp}
\cfgrule{op}{\cfgnt{binop} \cfgor \cfgnt{unaop} \cfgor \cfgq{set} \cfgor \cfgq{tuple}}
\cfgrule{setop}{\cfgq{setFilter} \cfgor \cfgq{setBuild}}

\cfgrule{k}{\cfgq{ret}}
	\cfgorline{\lp\cfgq{@} \cfgq{*} \cfgq{->} \cfgnt{k}\rp}
	\cfgorline{\lp\cfgnt{setop} \lp\cfgnt{pattern} \cfgq{in} \cfgq{*}\rp ~\cfgnt{e} \cfgq{->} \cfgnt{k}\rp}
	\cfgorline{\lp\cfgq{if} \cfgq{*} \cfgnt{e} \cfgnt{e} \cfgq{->} \cfgnt{k}\rp}
	\cfgorline{\lp\cfgq{pop} \cfgnt{$\eta$} \cfgnt{k}\rp}
	\cfgorline{\lp\cfgq{let} \lp\cfgq{[}\cfgnt{id} \cfgq{*}\cfgq{]}\rp ~\cfgnt{e} \cfgq{->} \cfgnt{k}\rp}
	\cfgorline{\lp \cfgnt{op} \lp\cfgnt{v} ...\rp \cfgq{*}
          \lp\cfgnt{e} ...\rp  \cfgq{->} \cfgnt{k}\rp}

\cfgend
\end{center}
\caption{Expression Machine Syntax}
\label{fig:expr:stx}
\end{figure}
\end{comment}

