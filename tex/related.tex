\section{Related Work}
\label{related}

While there exists a large body of work related to summary heaps,
we discuss work most closely related, including techniques for
scaling symbolic execution of programs with complex data types,
heap summary techniques, ...

%Recent years have seen a significant growth in research projects based
%on symbolic execution, first introduced in the 1970's by
%Clarke~\cite{Clarke:76} and King~\cite{King:76}.

Initial work on symbolic execution largely focused on checking 
properties of imperative programs with primitive
primitive types~\cite{Clarke:76,King:76}. Several recent projects 
generalized the core
idea of symbolic execution which enabled it to be applied to
programs with more general types, including references and 
arrays~\cite{GSE03,Godefroid:PLDI05,Sen:FSE05,CadarEngler05EXE,KiasanKunit}.
Our work leverages the core idea in generalized symbolic execution
with lazy initialization to construct the heap on-the-fly during symbolic
execution, but avoids the nondeterminism introduced by GSE by
constructing a summary heap and will generally create fewer paths
than GSE techniques.

%These projects have
%pursued three primary research directions to enhance traditional
%symbolic execution: (1)~to improve its
%effectiveness~\cite{Godefroid:PLDI05,Sen:FSE05,CadarEngler05EXE,KiasanKunit,Pasareanu:2011};
%(2)~to improve its
%efficiency~\cite{AnandETAL2009AbsSymExe,KhurshidSuen2005AbsSymExe,Godefroid:POPL07,Inkumsah:2008,ChangPhD10DataFlowSymbolicExecution,Santelices:ISSTA10,Visser:2012};
%and (3)~to improve its
%applicability~\cite{Person:FSE08,KhurshidETAL05RepairingStructurally,CsallnerETAL08DySy,SeoETAL06EnergyConsumptionFrameworkDistributedJava,Geldenhuys:2012,Ma:2011}.
%analyzing programs containing complex data structure with unbounded
%domains continues to be challenging
%for symbolic execution techniques.  Generalized symbolic execution \cite{GSE03}
%with lazy initialization set the path to materializing fields
%concretely. Subsequent improvements to the method
%\cite{Deng:2006,Deng:2007} to reduce path explosion by delaying path
%splitting over aliasing choices for as long as possible. However,
%since all of the above methods introduce nondeterminism during field
%reads and writes, they all contribute to path explosion to some
%extent.

% Since our heap representation does not introduce any nondeterminism
%beyond the level in standard symbolic execution, it will generally
%create fewer paths than these methods, sometimes by a wide margin.

%\subsection{Model Checking} Need to talk about Bounded Model
%Checking, etc.

%\subsection{Static Analysis}

A number of static analysis techniques have been proposed
to support reasoning about input heap structures~\cite{}. The technique
most closely related to (and which served as inspiration for) our approach
is the procedure summary proposed by Dillig et al. to support modular
reasoning~\cite{Dillig:2011}.  While
their method improves path sensitivity over standard static
analysis methods, it remains limited by a statically-generated
symbolic input heap and it cannot adapt to path-sensitive heap
properties of the input heap.

% These techniques are usually over-approximations, often have
% difficulty reasoning about path-sensitive properties, or cannot
% reason about programs with recursive data structures. Moreover,
% static analysis methods are seldom useful for test-case generation.

%. Elements of their technique that are similar to ours include;
%references guarded by constraint expressions, conditional write
%semantics, and a general aversion to path splitting. However, their
%method is limited by most of the standard problems with static
%analysis techniques, including path sensitivity, imprecision, and
%recursive data structures.

% Thus, their method cannot determine a priori which nodes in the
%input heap are actually accessed by the program. It may potentially
%generate input heaps containing a significant number of nodes that
%have no impact on program execution.

%\subsection{Heap Representations}

%One significant line of work on representing heaps is shape
%analysis. Shape analysis attempts to reduce the complexity of the
%heap by combining multiple nodes with similar properties into summary
%nodes. The summary nodes typically establish may/must constraints
%over the heap structure, and typically represent an overapproximation
%of the represented heap. As such, program evaluations using shape
%analysis representations are prone to reporting large numbers of
%false positives.

Other techniques have been proposed to model
references using sets of guarded
locations~\cite{Xie:2005,Cherem:2007,Dillig:2011,Sen:2014}. These sets,
sometimes known as value sets or value summaries, allow multiple heaps
to be represented simultaneously with a higher degree of precision
than afforded by shape analysis. However, some of these previous
attempts~\cite{Xie:2005,Cherem:2007} utilize non-local recursive
definitions for objects. The impact of such an approach is two-fold. 
First, these techniques must use approximations
to resolve reference inequalities, resulting in false positives in the
results. Second, these techniques are incapable of reasoning about
heaps with recursive data structures due to the potential for infinite
recursion during dereferencing. This means that either a large class
of data structures must be avoided, or a large class of behaviors must
be ignored. In our heap representation, object descriptions are
entirely local, thus avoiding these pitfalls. Other methods
\cite{Dillig:2011,Sen:2014}, while having local morphological
representations, do not provide for dynamic exploration of the initial
heap state.

Another line of work in heap representation lies in identifying
isomorphic heap structures in order to avoid exploring redundant
paths. Examples of such methods include Korat~\cite{Milicevic:2007},
XXX, and YYY. These
methods are generally focused on the morphology of the heap apart
from the external constraint problems encountered during
program execution, and as such, are largely orthogonal to this work.
