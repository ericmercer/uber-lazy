\section{Related Work}
\label{related}

In this section we discuss some closely related works, including
techniques for scaling symbolic execution of programs with complex
data types and heap summary techniques. Note that there is a huge body
of work on analyzing programs with heaps in the domain of static
analysis, testing, and verification.

Initial work on symbolic execution largely focused on checking
properties of imperative programs with primitive primitive
types~\cite{Clarke:76,King:76}. Several recent projects generalized
the core idea of symbolic execution which enabled it to be applied to
programs with more general types, including references and
arrays~\cite{GSE03,Godefroid:PLDI05,Sen:FSE05,CadarEngler05EXE,KiasanKunit}.
Our work leverages the core idea in generalized symbolic execution
with lazy initialization to construct the heap on-the-fly during
symbolic execution, but avoids the nondeterminism introduced by GSE by
constructing a summary heap and will generally create fewer paths than
GSE techniques.

Pex is a tool for dynamic symbolic execution for .NET programs. In
order to handle data structures Pex uses a theory of arrays and does
not initialization~\cite{Tillmann:2008}.  It is required to have a
constraint solver that handles the theory for unbounded arrays for
this approach to be tractable. It would be an interesting comparision
to perform in future work.

A number of static analysis techniques have been proposed to support
reasoning about input heap structures. The technique most closely
related to (and which served as inspiration for) our approach is the
procedure summary proposed by Dillig et al. to support modular
reasoning~\cite{Dillig:2011}.  While their method improves path
sensitivity over standard static analysis methods, it remains limited
by a statically-generated symbolic input heap and it cannot adapt to
path-sensitive heap properties of the input heap.

Other techniques have been proposed to model references using sets of
guarded
locations~\cite{Xie:2005,Cherem:2007,Dillig:2011,Sen:2014}. These
sets, sometimes known as value sets or value summaries, allow multiple
heaps to be represented simultaneously with a higher degree of
precision than afforded by shape analysis. However, some of these
previous attempts~\cite{Xie:2005,Cherem:2007} utilize non-local
recursive definitions for objects.  In our heap representation, object descriptions are
entirely local, thus avoiding these pitfalls. Other methods
\cite{Dillig:2011,Sen:2014}, while having local morphological
representations, do not provide for dynamic exploration of the initial
heap state.

There is also a large body of work on generating tests for
object-oriented programs that use a variety of techniques to generate
heap structures to test object-oriented
programs~\cite{xie2005symstra,xie2004rostra,boyapati2002korat,artzi2006finding}.
Another line of work in heap representation lies in identifying
isomorphic heap structures in order to avoid exploring redundant
paths~\cite{milicevic2007korat}.  These methods are generally focused
on the morphology of the heap apart from the external constraint
problems encountered during program execution, and as such, are
largely orthogonal to this work. Recent work shows that the need for
reasoning about heap structures is an important
problem~\cite{barr2013collecting}. Delta execution is another work
that combines states for object-oriented programs~\cite{d2008delta}.


%The impact of such an approach is two-fold.  First, these techniques
%must use approximations to resolve reference inequalities, resulting
%in false positives in the results. Second, these techniques are
%incapable of reasoning about heaps with recursive data structures due
%to the potential for infinite recursion during dereferencing. This
%means that either a large class of data structures must be avoided,
%or a large class of behaviors must be ignored.
