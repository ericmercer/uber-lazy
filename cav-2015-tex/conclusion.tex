\section{Conclusion}


Although our approach is inspired by the work in the static analysis
domain, the heap representations used by those techniques do not lend
themselves to symbolic execution since they rely on approximations,
they are inflexible in what types of relations can be expressed, and
they rely on rewriting of constraints.  In this work, we present a
heap summary technique for symbolic execution that maintains
exactness, represents arbitrary heap structures without restrictions
on aliasing relationships, and supports dynamic on-the-fly
initialization of heap structures. This unique combination of
capabilities enables the summary heap to outperform state-of-the-art
symbolic execution techniques, and in some cases, the performance
gains are considerable. We believe that performance gains in symbolic
execution can naturally benefit a variety of analyses based on
symbolic execution, for example, verification of properties,
especially those related to the heap, test case generation, program
evolution techniques such as directed incremental symbolic
execution~\cite{person:pldi2011}, and other back-end analyses. In
future work we will plan to evaluate the impact of analyses that rely
on symbolic execution.

\begin{comment}

In this work, we restricted our presentation of symbolic heaps to
constraints reasoning over heap morphology. However, in order to be
useful for reasoning about real programs, we must also consider the
impact of scalar types. Our implementation includes limited support
for linear operations over integer types, however, we plan to add
support for all types of operations such as floating point operations,
arrays, and bitvectors.




We have presented a new heap representation for symbolic execution that maintains exactness, represents arbitrary heap structures without restrictions on aliasing relationships, and supports dynamic on-the-fly initialization of heap structures. Despite this unique combination of capabilities, performance is not sacrificed compared to previous methods, and in some cases is greatly enhanced.

\subsection{Future Work}
Planned future work includes extensions to reason about scalar types, support for test case generation, state merging, and solver performance enhancements.

In this paper, we have restricted our presentation of symbolic heaps to constraints reasoning over heap morphology. However, in order to be useful for reasoning about real programs, we must consider the impact of scalar types. Our implementation includes limited support for linear operations over integer types, but we intent to extend support for all types of operations, as well as develop the theory for doing so.

Another feature we would like to add is support for test case
generation, which is traditionally a key advantage of symbolic
execution techniques. Under the current rules, it is difficult to
extract test cases because the heap may be destructively altered
during field writes. A simple remedy would be to maintain an explicit
input heap in addition to the actual heap which is mutated as the
program progresses.


Besides extending the capabilities of the algorithm, it should also be possible to increase performance through a variety of means. While our representation reduces paths significantly compared to \gsetxt{}, there remains room for improvement. Another way to reduce path explosion is through state merging. We are investigating ways of merging states at join points in the program, perhaps involving a combination of heap merging and / or heap equivalence testing as in \cite{Sen:2014}.

We are also contemplating a variety of performance optimizations that deal with constraints. Due to the structure of the constraints used in the heap representation, our representation is amenable to sophisticated results-caching schemes such as Green \cite{Visser:2012}. Likewise, a considerable amount of solver time is spent calculating object invariants during program initialization. In order to improve responsiveness during debugging operations, it should be possible to cache object invariants between test runs in to obtain a substantial speed-up.
\end{comment}



