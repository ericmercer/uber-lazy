\section{Proofs}

\input{definitions}

\subsection{Theorems}
%\begin{lemma}
%\label{lem:lazyrefprops}
%For any lazy state $s_\ell = ( \cfgnt{L}_\ell\ \cfgnt{R}_\ell\ \phi_\ell\ \eta_\ell\ \cfgnt{e}_\ell\ \cfgnt{k}_\ell )$, for any reference $r \in \cfgnt{L}_\ell^\leftarrow$, 
%$$ | \cfgnt{L}_\ell ( r) | = 1 $$
%\end{lemma}
%
%\begin{proof}
%In every rule in the Lazy machine that establishes a reference mapping, the value set contains exactly one location, constraint pair. 
%\end{proof}

\begin{theorem}[Mutual Exclusion]
\label{thm:mutex}
If we have a reachable summary state $s_s = ( \cfgnt{L}_s\ \cfgnt{R}_s\ \phi_s\ \eta_s\ \cfgnt{e}_s\ \cfgnt{k}_s )$, then for any reference $r \in \cfgnt{L}_s^\leftarrow$, and any two pairs $(\phi_\alpha\ l_\alpha) \in \cfgnt{L}_s(r)$ and $(\phi_\beta\ l_\beta) \in \cfgnt{L}_s(r)$ such that $l_\alpha \ne l_\beta$, then
$$(\phi_\alpha \wedge \phi_\beta) = \cfgt{false}$$
\end{theorem}
\begin{proof}
The proof will proceed inductively. 

Base Case: Let $s_s$ be an initial state. By Definition~\ref{def:initstate}, for every reference $r_i \in \cfgnt{L}_s^\leftarrow$, the set $\cfgnt{L}_s(r_i)$ contains at most one element. Thus, the requirement that $l_\alpha \ne l_\beta$ is never met, and the Theorem is vacuously true.

Inductive Step: Now we will show that if the exclusivity property holds for some state $s_s$, then it holds for any state $s_s^\prime$ where $s_s \rightarrow_s s_s^\prime$. In order to evaluate whether Theorem~\ref{thm:mutex} holds for state any $s_s\prime$, we must consider the rule that applied during the transition from $s_s$ to $s_s\prime$. There are two broad classes of rules: rules where $ \cfgnt{L}_s \neq  \cfgnt{L}_{s^\prime}$, and rules where $ \cfgnt{L}_s =  \cfgnt{L}_{s^\prime}$. Rules in the $ \cfgnt{L}_s \neq  \cfgnt{L}_{s^\prime}$ class modify the structure of the heap, and must be considered carefully to to consider the impact of those modifications. Only three rules belong to the class $ \cfgnt{L}_s \neq  \cfgnt{L}_{s^\prime}$: Field Access, Field Read, and New. 

We begin by considering the Field Access rule. Suppose $s_s$ has the form $\lp \cfgnt{L}_s\ \cfgnt{R}_{s}\ \phi_s\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp$. In this case, the relationship between $s_s$ and $s_s^\prime$ is described by the Field Access rule. The Field Access rule uses the Summarize rule to describe the relation between $\cfgnt{L}_{s}$ and $\cfgnt{L}_{s^\prime}$. Because the summarize rule is essentially a fixed-point computation, we can reason about it as a machine that produces a sequence of intermediate states $s_1, s_2, ... , s_n$. We will use an inductive argument to show that the mutual exclusion property holds for any of those intermediate states. First, let state $s_\alpha$ be any state for which the property in Theorem~\ref{thm:mutex} holds, and let $s_\beta$ be the intermediate state where $s_\alpha \rightarrow_S s_\beta$. If all fields are initialized, then $s_\alpha$ and $s_\beta$ are identical, so the mutually exclusive property holds for $s_\beta$. 
Otherwise, there must be some location $\cfgnt{l}_{un} \in \cfgnt{L}_\alpha(r)$ for which field f contains a reference $r_a$ that could feasibly point to the uninitialized location. In this case, a new reference is created and a single entry is added to $\cfgnt{L}_\beta$. The elements of the set $\theta_{all} = \cfgnt{L}_\beta(\cfgnt{R}_\beta(\cfgnf{l}_{un},\cfgnt{f}))$ can be divided into four distinct subsets, $\theta_{cur}$, $\theta_{null}$, $\theta_{new}$, and $\theta_{alias}$. The set $\theta_{cur}$ contains the pairs containing locations from the reference $r_a$, $\theta_{null}$ contains the pair with the null location, $\theta_{new}$ contains a pair with a new location, and $\theta_{alias}$ contains pairs representing alias locations. Any two constraints in $\theta_{cur}$ are guaranteed to be pairwise mutually exclusive because of the inductive hypothesis, and any single constraint is guaranteed to be pairwise mutually exclusive with any constraint in $\theta_{null}$, $\theta_{new}$, or $\theta_{alias}$ because constraints in $\theta_{cur}$ contain the conjunct $\neg \phi$, while constraints in the other three sets are conjoined with $\phi$. The set $\theta_{null}$ contains only one element, which in turn contains the constraint $r_f = r_{null}$, which is guaranteed to be mutually exclusive with any constraint in $\theta_{new}$, or $\theta_{alias}$ because constraints in those sets contain the conjunct $r_f \neq r_{null}$. The set $\theta_{new}$ contains one element, which in turn contains the constraint containing the conjunct $ \wedge_{\lp \cfgnt{r}^\prime_a,\ \phi^\prime_a,\ l^\prime_a\rp  \in \rho} \cfgnt{r}_f \ne \cfgnt{r}^\prime_a$, which is guaranteed to be mutually exclusive with any constraint in $\theta_{alias}$, because each constraint in that set contains the conjunct $r_f = r_a$ for some $(r_a\ \phi_a\ l_a)\in \rho$. Any two elements of the set $\theta_{alias}$ are guaranteed to pairwise mutually exclusive because for each constraint that contains the conjunct $r_f = r_a$, every other constraint contains the conjunct $r_f \ne r_a$. Thus, all constraints from all pairs in $\theta{all}$ are guaranteed to be mutually exclusive, and the property from Theorem~\ref{thm:mutex} holds for intermediate state $s_\beta$. 

We have now shown that whether there are any uninitialized fields or not, the mutual exclusivity property holds for any intermediate state $s_\beta$, so long as $s_\alpha \rightarrow_S s_\beta$ and the property holds for $s_\alpha$. 
So, since the mutual exclusivity property holds for $s_s$, $s_s \rightarrow_S s_1$, and $s_{i} \rightarrow_S s_{i+1} $ for all $i$ such that $0 < i < n$, we are guaranteed that the mutually exclusive property holds for the final intermediate state $s_n$. This concludes the inductive argument about intermediate state.

We now use this result to show that the mutual exclusion property holds for state $s_s^\prime$. The relation between the L-function from the final intermediate state $\cfgnt{L}^\prime$ and the L-function in $s_s^\prime$ is $ \cfgnt{L}_{s^\prime} = \cfgnt{L}^\prime[\cfgnt{r}^\prime \mapsto \mathbb{VS}\lp \cfgnt{L}^\prime,\cfgnt{R}^\prime,\cfgnt{r},\cfgnt{f},\phi_g\rp ]$, where a new value set is created based on the $\mathbb{VS}$ function. The members of the value set have the form $(\phi\wedge \phi^\prime\ \ l)$. Choose any two distinct members of the value set, $(\phi_\alpha \wedge \phi_\alpha^\prime\ \ l_\alpha)$ and $(\phi_\beta \wedge \phi_\beta^\prime\ \ l_\beta)$. If $\phi_\alpha \ne \phi_\beta$, we know that exclusivity holds because $\phi_\alpha$ and $\phi_\beta$ came from the same value set in $s_s$, and are therefore exclusive. If $\phi_\alpha = \phi_\beta$, we know that exclusivity holds because $\phi_\alpha^\prime$ and $\phi_\beta^\prime$ came from the same value set in $s_s$ and are therefore exclusive. Thus, the exclusivity property holds for any pair of constraints in the value set. Since the only new value set in $L_{s^\prime}^\rightarrow$ is generated by the $\mathbb{VS}$ function, we are guaranteed that if exclusivity holds for $s_s$, then exclusivity holds for $s_s^\prime$.

Suppose we have a field write instruction. This case is nearly identical as the field read. In this instruction, a new value set is created. The members of the value set have the form $(\phi\wedge \phi^\prime\ \ l)$. Choose any two distinct members of the value set, $(\phi_\alpha \wedge \phi_\alpha^\prime\ \ l_\alpha)$ and $(\phi_\beta \wedge \phi_\beta^\prime\ \ l_\beta)$. If $\phi_\alpha \ne \phi_\beta$, we know that exclusivity holds because $\phi_\alpha = \neg \phi_\beta$, so $\phi_\alpha$ and $\phi_\beta$ are therefore exclusive. If $\phi_\alpha = \phi_\beta$, we know that exclusivity holds because $\phi_\alpha^\prime$ and $\phi_\beta^\prime$ came from the same value set in $s_s$ and are therefore exclusive. Thus, the exclusivity property holds for any pair of constraints in the value set. Since exclusivity holds for the only new value set in $L_{s^\prime}^\rightarrow$, we are guaranteed that if exclusivity holds for $s_s$, then exclusivity holds for $s_s^\prime$.

Suppose we have a "new" instruction. In this case, only one value set is added to $L_{s^\prime}^\rightarrow$, and that value set contains only one member, so exclusivity holds by default.

Suppose we have any instruction other that a read, write, or new. No machine rule other than those three listed instructions modifies the $L$ function. Therefore, the exclusivity property must hold for $s_s^\prime$ in these cases.

Since the exclusivity property holds for any initial state, and since it holds for any "next" state if the property holds for the previous state, we have proven the property for every symbolic state.
\end{proof}

%\begin{comment}
%%I'm wondering... do we use this theorem anywhere? I think the place we needed it got re-structured, am I right?
%\begin{theorem}
%\label{thm:colex}
%If we have a summary state $s_s = ( \cfgnt{L}_s\ \cfgnt{R}_s\ \phi_s\ \eta_s\ \cfgnt{e}_s\ \cfgnt{k}_s )$, then for any reference $r \in \cfgnt{L}_s^\leftarrow$, 
%$$\bigvee \{ \phi \mid (\phi\ \cfgnt{l})\in \cfgnt{L}_s (\cfgnt{r})\} = \cfgt{true}$$
%\end{theorem}
%\begin{proof}
%The proof will proceed inductively.
%
%Base Case: In the initial state $s_0$ there is only one location, and all of it's fields are initialized to contain the uninitiated reference $\cfgnt{r}_{un}$. Since the only reference is the uninitialized reference, for which the desired property holds by construction, the property is true for all references on the heap.
%
%Inductive Step: 
%Suppose we have a summary state $s_s$ for which the property holds, and some state $s_s^\prime$ such that $s_s \rightarrow_S s_s^\prime$. If all relevant fields are initialized, then $s_s = s_s^\prime$, and the property holds trivially. If there is some uninitialized fields, then on of those fields will have a new reference $\cfgnt{r}_{new}$ added to it. The disjunction
%$$ \bigvee \{ \phi \mid (\phi\ \cfgnt{l})\in \cfgnt{L}_s (\cfgnt{r}_{new})\}$$
%Takes the form
%\begin{align*}
% (\phi_0) \vee (\neg \phi_0 \wedge \phi_1) \vee (\neg \phi_0 \wedge \neg \phi_1 \wedge \phi_2) \vee ...\\
% ... \vee (\neg \phi_0 \wedge \neg \phi_1 \wedge ... \wedge \phi_n) \vee (\neg \phi_0 \wedge \neg \phi_1 \wedge ... \wedge \neg \phi_n)
% \end{align*}
% Which reduces to $\cfgt{true}$. Thus, the collective exhaustion property holds for intermediate states. Because the property holds for intermediate states, for summary machine rules we will assume without loss of generality that all relevant fields are initialized. 
% Suppose that the rule executed in the transition from $s_s$ to $s_s^\prime$ is the field read rule. 
%Suppose we have a state $s_s$ for which the property holds, and some state $s_s^\prime$ such that $s_s \rightarrow_s s_s^\prime$. 
% 
%\end{proof}
%\end{comment}
%\begin{lemma}
%\label{lem:ref}
%For any symbolic state $s_s$, constraint $\phi$, and stack reference $\cfgnt{r}$ such that $(\phi\ \ell) \in \cfgnt{L}_s (\cfgnt{r})$, then 
%\begin{equation}
%\exists \Gamma_n^s\ ( \phi = \mathbb{PC} (\Gamma_n^s) )
%\end{equation}
%\end{lemma}
%\begin{proof}
%\end{proof}
%
%\begin{lemma}
%\label{lem:path}
%If there is some access path $\Gamma_n^s$ in state $s_s$ such that $\mathbb{S}(\phi_s \wedge \mathbb{PC}(\Gamma_n^s))$, then $\Gamma_n^\ell$ is an access path in some lazy state $s_\ell$ such that $s_\ell \sqsubset s_s$
%\end{lemma}
%\begin{proof}
%\end{proof}

\begin{lemma}[Exactness of Summarize Rule]
\label{lem:init}
If $s_s \cong \mathbb{FS}(\rightarrow_{\phi},s_0,\pi_n)$ for symbolic state $s_s = \lp \cfgnt{L}_s\ \cfgnt{R}_{s}\ \phi_s\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp$, initial state $s_0$, and control flow path $\pi_n$, and if there exists some intermediate state state $s_s^\prime$ such that $(\cfgnt{L}_s\ \cfgnt{R}_{s}\ \cfgnt{r}\ \cfgnt{f} \ \cfgnt{C}) \rightarrow_S^* (\cfgnt{L}_{s^\prime}\ \cfgnt{R}_{s^\prime}\ \phi_{s^\prime}\ \cfgnt{r}\ \cfgnt{f} \ \cfgnt{C})$, then:
 $$s_s^\prime \cong \{\forall s_\ell^\prime | \exists s_\ell (s_\ell \sqsubset s_s \wedge (s_\ell \rightarrow_I^* s_\ell^\prime) ) \}$$
\end{lemma}

\begin{proof}
In order for a state to be equivalent to a set of lazy states, it must be both sound and complete with respect to the set. We will begin the proof by showing completeness, and then finish by demonstrating soundness.

To show completeness, we must show that any state in the set is represented by $s_s$. The definition of representation requires the both the existence of a homomorphism, and proof that the homomorphism constraint is satisfiable. To show that a homomorphism exits, take any lazy state $s_\ell$ such that $s_\ell \sqsubset s_s$. By Definition~\ref{representation}, we know $s_\ell = \lp \cfgnt{L}_\ell\ \cfgnt{R}_\ell\ \phi_\ell\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp$. Take any state $s_\ell^\prime$ where $s_\ell \rightarrow_I^* s_\ell^\prime$, and state $s_s^\prime$ where $s_s \rightarrow_S^* s_s^\prime$. Note that  state $s_\ell^\prime$ has the form: $s_\ell^\prime = \lp \cfgnt{L}_{\ell^\prime}\ \cfgnt{R}_{\ell^\prime}\ \phi_{\ell^\prime}\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp$.Take any location, field pair $\lp l_\ell\  \cfgnt{f}\rp$ such that $\lp l_\ell\  \cfgnt{f}\rp \in \cfgnt{R}_{\ell}^\leftarrow$, and let $l_s = h(l_\ell)$. We may classify $l_\ell$ into one of three ways, based on the values of the $\cfgnt{R}$ function in each of the states $s_\ell$, $s_\ell^\prime$, $s_s$, and $s_s^\prime$, and we may define a function $h^\prime: \mathcal{L} \mapsto \mathcal{L}$ based on that classification.

Class 1: $\cfgnt{R}_\ell ( l_\ell,  \cfgnt{f} ) = \cfgnt{R}_{\ell^\prime} ( l_\ell,  \cfgnt{f} )$ and $\cfgnt{R}_{s} ( l_s,  \cfgnt{f} ) = \cfgnt{R}_{s^\prime} ( l_s,  \cfgnt{f})$.  Let $l_\alpha$ be the location such that ${(\phi_a\ l_\alpha)} = \cfgnt{L}_{\ell}(\cfgnt{R}_{\ell} (\cfgnt{l}_\ell,f )) $. In this case, let $h^\prime(l_\alpha) = h(l_\alpha)$. Since $s_\ell \rightharpoonup_h s_s$, we may surmise that: 
$$(\phi_a\ \cfgnt{l}_\alpha) \in \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_\ell,f )) \Rightarrow (\phi_b\ h^\prime (\cfgnt{l}_\alpha))\in \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} (\cfgnt{l}_s,f ))$$

Class 2: $\cfgnt{R}_\ell ( l_\ell,  \cfgnt{f}) = \cfgnt{R}_{\ell^\prime} ( l_\ell,  \cfgnt{f})$ and $\cfgnt{R}_{s} ( l_s,  \cfgnt{f}) \neq \cfgnt{R}_{s^\prime} ( l_s,  \cfgnt{f})$. Since $\cfgnt{R}_{s} ( l_s,  \cfgnt{f}) \neq \cfgnt{R}_{s^\prime} ( l_s,  \cfgnt{f})$, the Summarize rule must have altered this reference. A reference created by the Summarize rule has a value set $\theta_{all}$ with four subsets: $\theta_{null}$, $\theta_{new}$, $\theta_{alias}$, and $\theta_{orig}$. Because $\cfgnt{R}_\ell ( l_\ell,  \cfgnt{f}) = \cfgnt{R}_{\ell^\prime} ( l_\ell,  \cfgnt{f})$, we know that the location we want to map to lies in $\theta_{orig}$. Let $l_\alpha$ be the location such that ${(\phi_a\ l_\alpha)} = \cfgnt{L}_{\ell}(\cfgnt{R}_{\ell} (\cfgnt{l}_\ell,f )) $, and let $l_{orig} = h(l_\alpha)$. In this case, we let $h^\prime(l_\alpha) = h(l_\alpha)$. Since $(\phi_a\ l_\alpha) \in \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_\ell,f ))$. Let $l_{orig} = h(l_\alpha)$. We can see that by the Summarize rule $ (\phi_b\ l_{orig})\in \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} (\cfgnt{l}_s,f ))$, so therefore:
$$(\phi_a\ \cfgnt{l}_\alpha) \in \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_\ell,f )) \Rightarrow (\phi_b\ h^\prime (\cfgnt{l}_\alpha))\in \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} (\cfgnt{l}_s,f ))$$

Class 3: $\cfgnt{R}_\ell ( l_\ell,  \cfgnt{f}) \neq \cfgnt{R}_{\ell^\prime} ( l_\ell,  \cfgnt{f})$ and $\cfgnt{R}_{s} ( l_s,  \cfgnt{f}) \neq \cfgnt{R}_{s^\prime} ( l_s,  \cfgnt{f})$. In this case, there are two possibilities: either the new reference $\cfgnt{R}_{\ell^\prime} ( l_\ell,  \cfgnt{f})$ points to some location we've seen before $l_\alpha$, or it points to a previously unobserved location $l_\beta$. By establishing which of these possibilities has happened, we can build $h^\prime$. To construct $h^\prime$, let $l_\alpha$ be any location such that $(\phi_a\ \cfgnt{l}_\alpha) \in \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_\ell,f )) $. If there exists $\phi_\alpha$ such that $\lp \phi_\alpha\ l_\alpha \rp \in \cfgnt{L}_{\ell}^\rightarrow $, let $h^\prime(l_\alpha) = h(l_\alpha)$. Otherwise, let $l_\beta$ be the location such that $(\phi_b\ \cfgnt{l}_\beta) \in \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} (\cfgnt{l}_s,f )) $ and $(\phi_b\ \cfgnt{l}_\beta) \notin \cfgnt{L}_{s}(\cfgnt{R}_{s} (\cfgnt{l}_s,f )) $. Now, let $h^\prime(l_\alpha) = l_\beta$. Observe that either way,
$$(\phi_a\ \cfgnt{l}_\alpha) \in \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_\ell,f )) \Rightarrow (\phi_b\ h^\prime (\cfgnt{l}_\alpha))\in \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} (\cfgnt{l}_s,f ))$$

Furthemore, since $l_\alpha$ and $l_\beta$ are new locations with uninitialized fields, we know that for any field $f^\prime$, $\{(\phi_p\ \bot)\} = \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_\alpha,f^\prime ))$ and $ \{(\phi_p\ \bot)\} = \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} (\cfgnt{l}_\beta,f^\prime ))$ therefore, we know that:
$$(\phi_p\ \cfgnt{l}_x) \in \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_\alpha,f^\prime )) \Rightarrow (\phi_q\ h^\prime (\cfgnt{l}_x))\in \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} ( h^\prime(\cfgnt{l}_\alpha),f ))$$

We have now shown that there exists a mapping $h^\prime: \mathcal{L} \mapsto \mathcal{L}$ for all $\cfgnt{l}_{\ell^\prime} \in \cfgnt{L}_{\ell^\prime}^\rightarrow$ such that:
$$ (\phi_a\ \cfgnt{l}_\alpha) \in \cfgnt{L}_{\ell^\prime}(\cfgnt{R}_{\ell^\prime} (\cfgnt{l}_{\ell^\prime},f )) \Rightarrow (\phi_b\ h^\prime (\cfgnt{l}_\alpha))\in \cfgnt{L}_{s^\prime}(\cfgnt{R}_{s^\prime} (\cfgnt{l}_{\ell^\prime},f )) $$
By Definition~\ref{def:homomorphism} we know that $s_\ell^\prime \rightharpoonup_{h^\prime} s_s^\prime$. 

It remains to show that $\mathbb{S}( \phi_s^\prime \wedge \mathbb{HC}(s_\ell^\prime \rightharpoonup_{h} s_s^\prime) )$. For locations in Class 1, no new conjuncts are added to $\mathbb{HC}(s_\ell^prime \rightharpoonup_{h} s_s^\prime)$, and therefore the satisfiability cannot be changed. For locations in Class 2 or Class 3, the new constraints take either the form $\phi_x \wedge \phi_{orig}$, or $\phi_x \wedge (r_f\ op\ r_{a}) \wedge (r_f\ op\ r_{b}) \wedge ...$. Constraints of the form  $\phi_x \wedge \phi_{orig}$ contain terms $\phi_x$ and $\phi_{orig}$ which were already conjoined to prior heap constraint, so satisfiability is not affected. In constraints of the form $\phi_x \wedge (r_f\ op\ r_{a}) \wedge (r_f\ op\ r_{b}) \wedge ...$, the term $\phi_x$ is conjoined to the prior heap constraint, and all the other terms involve the new variable $r_f$, so satisfiability is not affected. Since the previous heap constrain is satisfiable, and none of the new terms can impact the satisfiability, we know that the new heap constraint must also be satisfiable.

Since the heap constraint is satisfiable, we know that $s_\ell^\prime \sqsubset s_s^\prime $. We have therefore shown that for some summary state $s_s$ and an arbitrary lazy state $s_\ell$ such that $s_\ell \sqsubset s_s$ :
\begin{equation} 
(s_\ell \rightarrow_I^* s_\ell^\prime \wedge s_s \rightarrow_S^* s_s^\prime) \Rightarrow s_\ell^\prime \sqsubset s_s^\prime 
\end{equation}


%may take one of four forms: either the field is already initialized, or the uninitialized field is initialized to a new reference, the null reference, or an alias.
%
%We now show that the following four cases for $s_\ell^*$ are represented in $s_s^*$. For the following cases, let $\rightharpoonup_{h}$ be the homomorphism such that $s_\ell \rightharpoonup_{h} s_s$, let $\cfgnt{l}_\ell = \cfgnt{L}_\ell(\cfgnt{r})$, and let $\cfgnt{l}_s = h(\cfgnt{l}_\ell) $
%
%Case 1: Suppose $\cfgnt{R}_\ell(\cfgnt{l}_\ell) \neq \bot$. In this case, because $s_\ell \rightharpoonup_{h} s_s$, we know that $\cfgnt{R}_s(\cfgnt{l}_s) \neq \bot$. This means that in the Summarize rule, $\cfgnt{l}_s \notin \Lambda$, and therefore, $\cfgnt{R}_s(\cfgnt{l}_s) = \cfgnt{R}_{s^*}(\cfgnt{l}_s) $. By extension, 
%
%Case 2: Suppose the field is uninitialized, and the "new" rule gets executed. We add a new location, so this case is represented.
%
%Case 3: Suppose the field is uninitialized, and the "null" rule gets executed. We add a link to the null location, so this case is represented.
%
%Case 4: Suppose the field is uninitialized, and the "alias" rule gets executed. We add links to all possible aliases, so this case is also represented. In fact, we add more links than we really need, but the extra ones are infeasible for the case in question so it's not a problem. 
%
%%for the next case, we need to show that the constraints in the symbolic heap don't allow any infeasible heaps. The key to this will be in showing that the constraints are mutually exclusive and collectively exhaustive. Mutually exclusive constraints are required because lazy heaps only point to one place at at time. Collectively exhaustive constraints are required to eliminate any other possible heaps. We could start by explicitly enumerating the members of the product feasible set, and working from there to show that the symbolic heap is equivalent to that set. Or, we might do this on a case-by-case basis to show that for an arbitrary lazy state, any of it's three possible target states is in the feasible set.
%
%Having demonstrated each of these four cases, we now know that 
%$$s_\ell^* \in \{\forall s_\ell^\prime | \exists s_\ell \sqsubset s_s (s_\ell \rightarrow_I^* s_\ell^\prime)  \} \Rightarrow  s_\ell^* \sqsubset s_s^*$$

%Comment:
% there is a flaw in the following argument: we claim that "every reference points to the right place at the right time" However, this statement is misleading. The truth is that the way we've defined representation, we can only guarantee that every reference points to the right place at some right time, not every right time like we imply here. The rest of the argument falls apart unless we can first prove that every reference points to the right place at every right time. So, instead of saying A points to B some time when condition X is true, we need to say that A points to B every time condition X is true. In other words, that condition X implies A points to B. This is easy to prove if we don't introduce new variables into the Heap Condition. However, in this case we certainly do introduce a new variable: it's the new reference that we put into the empty field.
%Flawed argument:
%We now prove the reverse case, that $s_s^*$ represents no infeasible states. We modified no references from the previous heap, and did not alter the global invariant. This means that every old reference points to the right place at the right time, and that no old reference points to the wrong place at the wrong time.  Thus, if there is a problem with a reference, it must be with one of the new references we created. Since we have already proved that every reference points to the right place at the right time (WARNING: though the preceding statement may be true, we haven't actually proved it yet. See the above comment), there must be some field that points to the wrong place at the wrong time. Since we know that every field points to the right place at the right time, and since we know that the constraints are mutually exclusive, we know that the "wrong time" can never be at the same time as the "right time". Since the right time is every time due to Theorem~\ref{thm:colex}, this implies that the wrong time is no time. 

%okay, here is another crack at proving soundness
We now prove the reverse case, that $s_s^*$ represents no infeasible states. Suppose that $s_s^\prime$ represents some infeasible state. This means that we represent some lazy state that has some reference r which points somewhere that no place in the feasible set points to. Since we don't change the path condition, all the old references still point exactly to the same places they used to. So, the problem must be with one of the new references. All of the new references point to either a new location, the null location, the uninitialized location, or some alias. The new, null, and uninitialized locations are pretty straightforward and easy to show that they are all pointing to the correct places at the correct times. This means that there must be a feasible path to a target location that does not exist for any lazy heap. So, pick an arbitrary lazy heap containing the location and field in question. If said target location does not exist, then there is no reference in the lazy heap pointing to that location. In the summary heap, the path constraint on the path leading to the undesired target contains an aliasing condition that states that the source reference only points to this target location on condition that the parent reference points there. However, since we already know that no other reference in the lazy heap points there, this condition must be infeasible. Therefore, it is not part of the represented state. We have a contradiction. Therefore, there is no alias that points somewhere it's not supposed to.

We have now proven that 
$$ s_\ell^* \sqsubset s_s^*  \Rightarrow  s_\ell^* \in \{\forall s_\ell^\prime | \exists s_\ell (s_\ell \sqsubset s_s \wedge (s_\ell \rightarrow_I^* s_\ell^\prime) ) \}$$
This fact, combined with our previous result, proves that
$$s_s^*  \cong \{\forall s_\ell^\prime | \exists s_\ell (s_\ell \sqsubset s_s \wedge (s_\ell \rightarrow_I^* s_\ell^\prime) ) \}$$

\end{proof}

%we need to define how r' is arrived at for this one to work...
\begin{lemma}[Exactness of Field Access Rule]
\label{lem:access}
If there are symbolic states $s_s$ and $s_s^\prime$, control sequences $\pi_n$ and $\pi_{n+1}$, initial state $s_0$, and reference $\cfgnt{r}^\prime$ such that the following conditions hold:
\begin{align}
s_s &= \lp \cfgnt{L}_{\mathcal{S}}\ \cfgnt{R}_{\mathcal{S}}\ \phi_g\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp \\
s_s &\cong \mathbb{FS}\lp \rightarrow_{\phi},s_0,\pi_n\rp \\
\cfgnt{r}^\prime &= \mathrm{fresh}_r\lp \rp \\
\pi_{n+1} &=\pi_n\ \lp \eta\ \cfgnt{r}^\prime\ \cfgnt{k} \rp \\
s_s &\rightarrow_s s_s^\prime
\end{align}
%$$s_s = \lp \cfgnt{L}_{\mathcal{S}}\ \cfgnt{R}_{\mathcal{S}}\ \phi_g\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp$$ 
%$$s_s \cong \mathbb{FS}\lp \rightarrow_{\phi},s_0,\pi_n\rp$$ 
%$$\pi_{n+1} =\pi_n\ \lp \eta\ \cfgnt{r}^\prime\ \cfgnt{k} \rp$$ 

then 
$$s_s^\prime \cong \mathbb{FS}\lp \rightarrow_{\phi},s_0,\pi_{n+1} \rp$$
\end{lemma}

\begin{proof}
Begin by assuming the conditions stated in Lemma~\ref{lem:access}. We will consider two cases for this proof. In the first case, we assume that all of the fields involved in the read are initialized. In the second case we consider uninitialized fields. 

Case 1: Suppose all of the pertinent fields in $s_s$ are initialized. Take an arbitrary lazy state $s_\ell$ such that $s_\ell \sqsubset s_s$. Since $s_s$ is exact,  $s_\ell = \lp \cfgnt{L}_{\ell}\ \cfgnt{R}_{\ell}\ \phi_\ell\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k} \rp \rp$, and $s_\ell \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_n)$. If we apply the state transition functions to achieve states $s_\ell^\prime$ and $s_s^\prime$ such that $s_\ell \rightarrow_\ell s_\ell^\prime$ and  $s_s \rightarrow_s s_s^\prime$, we find that according to the Field Access rule:
$$s_\ell^\prime = \lp \cfgnt{L}_{\ell} [\cfgnt{r}^\prime \mapsto \lp\phi^\prime\ l^\prime\rp]\ \cfgnt{R}_{\ell}\ \phi_L\ \eta\ \cfgnt{r}^\prime\ \cfgnt{k}\rp $$
 and 
 $$ s_s^\prime = \lp \cfgnt{L}_{s}[\cfgnt{r}^\prime \mapsto \mathbb{VS}\lp \cfgnt{L}_{s},\cfgnt{R}_{s},\cfgnt{r},\cfgnt{f},\phi_g\rp ]\ \cfgnt{R}_{s}\ \phi_g\ \eta\ \cfgnt{r}^\prime\ \cfgnt{k}\rp $$

We now show that $s_\ell^\prime \sqsubset s_s^\prime$. Since $\eta$, $e$, and $k$ are identical between $s_s^\prime$ and $s_\ell^\prime $, the first condition is met by default. Now we construct the function $h^\prime$ such that $h^\prime = h$. Observe that since $s_\ell \rightharpoonup_{h} s_s$, and since $\cfgnt{R}_\ell$ and $\cfgnt{R}_s$ are unchanged from states $s_\ell$ to $s_\ell^\prime$ and $s_s$ to $s_s^\prime$ respectively, we are guaranteed that $ \cfgnt{r} = \cfgnt{R}_\ell(l,f) \Rightarrow \cfgnt{r} = \cfgnt{R}_s(h^\prime(l),f)$. Let $\{(\phi_\ell^\prime\ l^\prime)\} =  \cfgnt{L}_\ell(\cfgnt{R}_\ell(l,f))$. Since $\mathbb{S}(\phi_g \wedge \mathbb{HC}(s_\ell \rightharpoonup_{h} s_s))$ is valid, we know that:
 $$(\phi_s \wedge \phi_s^\prime\ h(l^\prime)) \in \mathbb{VS}\lp \cfgnt{L}_{s},\cfgnt{R}_{s},\cfgnt{r},\cfgnt{f},\phi_g\rp$$ 
From this, we may deduce that:
$$ (\phi_\ell\ l) \in \cfgnt{L}_\ell^\prime(\cfgnt{r}^\prime) \Rightarrow (\phi_s \wedge \phi_s^\prime\ h^\prime(l))\in \cfgnt{L}_s^\prime(\cfgnt{r}^\prime)$$
Since $\cfgnt{r}^\prime$ is the only new addition to $L_\ell^\prime$ and $L_s^\prime$, we now know that the assertion above holds for all $l \in \mathcal{L}$. Thus, we have shown that $s_\ell^\prime \rightharpoonup_{h} s_s^\prime$. Furthermore, since the constraints in $\mathbb{HC}(s_\ell^\prime \rightharpoonup_{h^\prime} s_s^\prime)$ are constructed using conjuncts already present in $ \mathbb{HC}(s_\ell \rightharpoonup_{h} s_s)$, we are guaranteed that $\mathbb{HC}(s_\ell^\prime \rightharpoonup_{h^\prime} s_s^\prime) \Leftrightarrow \mathbb{HC}(s_\ell \rightharpoonup_{h} s_s)$, and therefore $\mathbb{S}(\phi_g \wedge \mathbb{HC}(s_\ell^\prime \rightharpoonup_{h^\prime} s_s^\prime))$. This fact, and the fact that $\eta_{\ell} = \eta_{s} ,\ \cfgnt{e}_{\ell} = \cfgnt{e}_{s} ,\ \cfgnt{k}_{\ell} = \cfgnt{k}_{s}$, means that by Definition~\ref{representation} we know $s_\ell^\prime \sqsubset s_s^\prime$. We have now shown that for any lazy state $s_\ell$: 
\begin{equation}
\label{eqn:slimpliesslprime}
s_\ell \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_n) \Rightarrow s_\ell^\prime \sqsubset s_s^\prime
\end{equation}

Since there is only one possible control flow sequence $\pi_{n+1}$, this means that if $s_\ell \rightarrow_\ell s_\ell^\prime$, then 
\begin{equation}
\label{eqn:slimpliesslprime2}
s_\ell \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_n) \Leftrightarrow s_\ell^\prime\ \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})
\end{equation}

Combining Equations \ref{eqn:slimpliesslprime} and \ref{eqn:slimpliesslprime2}, we may finally conclude that $s_s^\prime$ is complete with respect to $\mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})$
\begin{equation}
\label{eqn:readforwards}
s_\ell^\prime \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1}) \Rightarrow s_\ell^\prime \sqsubset s_s^\prime
\end{equation}

%Now, suppose that there exists a state $s_i^\prime$ such that $s_i^\prime \sqsubset s_s^\prime$, but $s_i^\prime \notin \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})$. Since $s_i^\prime \sqsubset s_s^\prime$, then by Lemma~\ref{lem:ref}, $\cfgnt{r}^\prime$ represents a valid path $\Gamma_{n+1}^{s\prime}$, in states $s_i^\prime$ and $s_s^\prime$. Furthermore, by Lemma~\ref{lem:path} we can surmise that $\mathbb{S}(\phi_s^\prime \wedge \mathbb{PC}(\Gamma_{n+1}^{s\prime}))$. By construction, $\Gamma_{n+1}^{s\prime}$ is an extension of the valid access path $\Gamma_{n}^{s}$ represented by reference $\cfgnt{r}$ in state $s_s$. Since $s_s$ is exact, there exists state $s_i$ such that $s_i \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n})$. and by our previous result, $s_i^\prime \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})$. We have a contradiction.

Now, suppose that there exists a state $s_i^\prime$ such that $s_i^\prime \sqsubset s_s^\prime$, but $s_i^\prime \notin \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})$. Since $s_i^\prime \sqsubset s_s^\prime$, then by Definition~\ref{representation}, we know there exists a homomorphism $s_i^\prime \rightharpoonup_{h^\prime} s_s^\prime$, and that $\mathbb{S}( \phi_i^\prime \wedge \mathbb{HC}(s_i^\prime \rightharpoonup_{h^\prime} s_s^\prime) )$. From state $s_i^\prime$, construct state $s_i$ such that 
\begin{align*}
s_i &= \lp \cfgnt{L}_{i}\ \cfgnt{R}_{i}\ \phi_i\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp\\
L_i &= L_{i^\prime} \setminus \{\cfgnt{r}^\prime \}\\
R_i &= R_{i^\prime}\\
\phi_i &= \phi_i^\prime
\end{align*}
Observe that by virtue of the lazy Field Access rule, $s_i \rightarrow_\ell s_i^\prime$. Now, construct function $h_i$ so that $h_i = h^\prime$. Observe that by Definition~\ref{def:homomorphism} $s_i \rightharpoonup_{h_i} s_s$,  and that $\mathbb{S}( \phi_i \wedge \mathbb{HC}(s_i \rightharpoonup_{h_i} s_s) )$, so $s_i \sqsubset s_s$. Since $s_s$ is exact, $s_i \in\mathbb{FS}(\rightarrow_{\ell},s_0,\pi_n)$. Combining this with the fact that $s_i \rightarrow_\ell s_i^\prime$, we conclude that $s_i^\prime \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})$. We have a contradiction.

 Therefore, $s_s^\prime$ is sound with respect to $\mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})$:
 \begin{equation}
 \label{eqn:readbackwards}
 s_i^\prime \sqsubset s_s^\prime \Rightarrow s_i^\prime \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1})
 \end{equation}
Since $s_s$ is both sound and complete, we may combine Equations \ref{eqn:readforwards} and \ref{eqn:readbackwards} to find that 
$$s_\ell^\prime \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n+1}) \Leftrightarrow s_\ell^\prime \sqsubset s_s^\prime$$
By Definition~\ref{equivalent}, $s_s^\prime \cong \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_n)$, and so by Definition~\ref{exact}, $s_s^\prime$ is exact.

Case 2: If there are uninitialized fields, then the lazy initialization machine will make an intermediate state $s_t$. By Lemma~\ref{lem:init}, the summary intermediate state is equivalent to the set of lazy intermediate states. Since the summary intermediate state From the intermediate state, the proof is the same as for case 1.
\end{proof}

%proof for field write
\begin{lemma}[Exactness of Field Write Rule]
\label{lem:write}
If symbolic state $s_s =  \lp \cfgnt{L}_s\ \cfgnt{R}_s\ \phi_s\ \eta\ \cfgnt{r}\ \lp \cfgnt{x}\ \cfgt{\$}\ \cfgnt{f}\ \cfgt{:=}\ \cfgt{*}\ \rightarrow\ \cfgnt{k}\rp \rp$ is exact with respect to some initial state $s_0$ and control flow path $\pi_n$, and if $s_s \rightarrow_s s_s^\prime$ for some state $s_s^\prime$, then $s_s^\prime$ is equal to $ \lp \cfgnt{L}_{s^\prime}\ \cfgnt{R}_{s^\prime}\ \phi_{s^\prime}\ \eta\ \cfgnt{k}\rp$ and is exact with respect to $s_0$ and $\pi_n \ (\eta\ \cfgnt{k}\ \emptyset)$.

\end{lemma}
\begin{proof}
By Lemma~\ref{lem:init} we know that if $s_s$ is exact, then the intermediate state $s_x$ such that $s_s \rightarrow_S^* s_x$ is also exact. Thus, for $s_s$ and any state  $s_i$ such that $s_i \sqsubset s_s$ we will assume, without loss of generality, that all relevant fields have been initialized.

First, we show that every state in the feasible set is represented by $s_s^\prime$. Take some lazy state $s_i$ such that $s_i \sqsubset s_s$. Observe that the field write rule places every possible target value into the reference stored at the target location. Thus, whatever the write value was for $s_i^\prime$ was, it was written to the target field, meaning $s_i^\prime$ is represented by $s_s^\prime$.

Next, we show that every state represented by $s_s^\prime$ is in the feasible set. We use the same argument as in the field read proof, that because $s_s^\prime$ represents every state in the feasible set, and since the cardinality of the set of states represented by $s_s^\prime$ is less than or equal to the cardinality of the feasible set, that $s_s^\prime$ can only represent feasible states.

\end{proof}

%proof for reference compares. Here we will rely on the fact that since the L and R functions don't change, and since the phi function
\begin{lemma}[Exactness of Reference Compare Rule]
\label{lem:compare}
If symbolic state $s_s =  \lp \cfgnt{L}_s\ \cfgnt{R}_s\ \phi_s\ \eta\ \cfgnt{r}_0\ \lp \cfgnt{r}_1\; \cfgt{=}\; \cfgt{*} \rightarrow \cfgnt{k}\rp \rp$ is exact with respect to some initial state $s_0$ and control flow path $\pi_n$, and if $s_s \rightarrow_s s_s^\prime$ for some state $s_s^\prime$, then $s_s^\prime$ is equal to $ \lp \cfgnt{L}_s\ \cfgnt{R}_s\ \phi_{s^\prime}\ \eta\ \cfgnt{v}_{s^\prime}\ \cfgnt{k}\rp$ and is exact with respect to $s_0$ and $\pi_n \ (\eta\ \cfgnt{v}_{s^\prime}\ \cfgnt{k})$.
\end{lemma}
There are two rules that apply to state $s_s$, one for the $\cfgt{true}$ branch and one for the $\cfgt{false}$ branch. Since the proofs for both rules are nearly identical, for brevity we will only show the proof for the case for the $\cfgt{true}$ branch. 
\begin{proof}
Choose any $s_\ell \sqsubset s_s$, and let $\zeta_T = \mathbb{FS}(\rightarrow_{\ell},s_0,(\pi_n,(\eta\ \cfgt{true}\ \cfgnt{k})))$. Since $s_s$ is exact, we know that $s_\ell \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_n)$, $s_l = \lp \cfgnt{L}_\ell\ \cfgnt{R}_\ell\ \phi_\ell\ \eta\ \cfgnt{r}_0\ \lp \cfgnt{r}_1\; \cfgt{=}\; \cfgt{*} \rightarrow \cfgnt{k}\rp \rp$, and that there exists a homomorphism $s_\ell \rightharpoonup_{h} s_s$ such that $\mathbb{S}( \phi_s \wedge \mathbb{HC}(s_\ell \rightharpoonup_{h} s_s) ) $. 
Depending on the values of $\cfgnt{L}_\ell \lp \cfgnt{r}_0\rp$ and $\cfgnt{L}_\ell \lp \cfgnt{r}_1 \rp$, there are two different rules that might apply to $s_\ell$.
%I'm not sure we actually use this fact anywhere
 %In either case, $\cfgnt{L}_\ell$ and $\cfgnt{R}_\ell$ are unchanged, and $\phi_\ell$ is strengthened, so we already know that 
%$$ \zeta_T \subseteq \{s_\ell^\prime | \exists s_\ell \in \mathbb{FS}(\rightarrow_{\ell},s_0,\pi_{n}) (s_\ell \rightarrow_\ell s_\ell^\prime )\}$$

Case 1: Assume $\cfgnt{L}_\ell \lp \cfgnt{r}_0\rp = \cfgnt{L}_\ell \lp \cfgnt{r}_1 \rp$, and let 
$$\zeta_t = \zeta_T \setminus \{ s_f | (s_f= \lp \cfgnt{L}_f\ \cfgnt{R}_f\ \phi_\ell\ \eta\ \cfgnt{e}\ \cfgnt{k}\rp) \wedge (\cfgnt{L}_f \lp \cfgnt{r}_0\rp \neq \cfgnt{L}_f \lp \cfgnt{r}_1 \rp ) \}$$
In this case, the lazy ``equals - references true" rule applies, and we know state $s_\ell^\prime : s_\ell \rightarrow_\ell s_\ell^\prime$ is in $\zeta_t$. Observe that by applying Theorem~\ref{thm:mutex}, $\phi_s^\prime \wedge \phi_0 \wedge \phi_1$ reduces to $\phi_s$. Therefore, $\mathbb{S}( \phi_s^\prime \wedge \mathbb{HC}(s_\ell^\prime \rightharpoonup_{h} s_s^\prime) ) $ is true, and by extension, $s_\ell^\prime \sqsubset s_s^\prime$. Since this relation holds for arbitrary $s_\ell^\prime \in \zeta_t$, we now know that $$s_\ell^\prime \in \zeta_t \Rightarrow s_\ell^\prime \sqsubset s_s^\prime$$
Now we prove the case for the other direction. Consider a state $s_s^\prime$ where  $s_s \rightarrow_s s_s^\prime$. Define $\theta_\alpha$, $\theta_0$ and $\theta_1$ as in the ``equals (references-true) rule''. Since $\cfgnt{L}_s$ and $\cfgnt{R}_s$ are unchanged from $s_s$, and $\phi_s^\prime$ is only a strengthened version of $\phi_s$,  we know that
$$\{s_\ell^\prime | s_\ell^\prime \sqsubset s_s^\prime \} \subseteq \{s_\ell^\prime | \exists s_\ell \lp s_\ell \sqsubset s_s \rp \wedge s_\ell \rightarrow_s s_\ell^\prime\} $$
Suppose that there exists state $s_i^\prime$ such that $s_i^\prime \sqsubset s_s^\prime$ and $s_i^\prime \notin \zeta_t$. Because of the above conclusion, we know that $$s_i^\prime \in \{s_\ell^\prime | \exists s_\ell \lp s_\ell \sqsubset s_s\rp \wedge s_\ell \rightarrow_s s_\ell^\prime\}$$ 
Combining this with the assumption that $s_i^\prime \notin \zeta_t$, we must conclude that $\cfgnt{L}_\ell \lp \cfgnt{r}_0\rp \neq  \cfgnt{L}_\ell \lp \cfgnt{r}_1 \rp$. Because of this, and because of Theorem~\ref{thm:mutex}, we know that either all constraints in the set
$$\{\phi_i \mid \exists \phi_\alpha (\phi_\alpha \in \theta_\alpha)\wedge \phi_i = \lp\phi_\alpha \wedge \phi_0 \wedge \phi_1\rp\}$$ are unsatisfiable, or that at least one constraint in the set
$$\{\phi_i \mid \exists \phi_\alpha (\phi_\alpha \in \lp \theta_0 \cup \theta_1 \rp)\wedge \lp \phi_i = \phi_\alpha \wedge \phi_0 \wedge \phi_1 \rp\}$$ 
is valid. Either way, $\mathbb{S}\lp\phi_i^\prime \wedge\phi_0\wedge \phi_1\rp$ is false and $s_s^\prime$ does not represent $s_i^\prime$. We have a contradiction. Therefore: $$s_\ell^\prime \sqsubset s_s^\prime \Rightarrow s_\ell^\prime \in \zeta_t$$
Combining this with our previous result, we conclude that $$s_\ell^\prime \in \zeta_t \Leftrightarrow s_\ell^\prime \sqsubset s_s^\prime$$

Case 2: Assume $s_\ell : \cfgnt{L}_\ell \lp \cfgnt{r}_0\rp \neq \cfgnt{L}_\ell \lp \cfgnt{r}_1 \rp$, and let 
$$\zeta_f = \zeta_T \setminus \{ s_t | \cfgnt{L}_t \lp \cfgnt{r}_0\rp = \cfgnt{L}_t \lp \cfgnt{r}_1 \rp \}$$ 
This means that the lazy ``equals - references false" rule applies. The proof for the ``equals - references false" rule is highly similar to the proof for ``equals - references true", so we omit it for the sake of brevity. The result for this case is:
$$s_\ell^\prime \in \zeta_f \Leftrightarrow s_\ell^\prime \sqsubset s_s^\prime$$

Since $\zeta_T = \zeta_t \cup \zeta_f$, we can combine the results of the two cases to find that 
$$s_\ell^\prime \in \zeta_T \Leftrightarrow s_\ell^\prime \sqsubset s_s^\prime$$
 By Definition~\ref{equivalent}, $s_s^\prime \equiv \zeta_T$, and by Definition~\ref{exact}, $s_s^\prime$ is exact.
\end{proof}

\begin{theorem}[Exactness of Summary Machine States]
If $\Pi_n^s$ is a feasible summary state sequence, then the final state in $\Pi_n^s$ is equivalent to the feasible set of lazy states sharing the same control flow sequence:
\begin{equation}
\mathit{last}(\Pi_n^s) \cong \mathbb{FS}(\rightarrow_\ell, \mathit{first}(\Pi_n^s), \mathbb{CF}(\Pi_n^s) )
\end{equation}
\end{theorem}
\begin{proof}
The proof will proceed inductively.

Base case: For any initial state $s_0$, the feasible state set contains a single element, $\{s_0\}$:
$$\mathbb{FS}(\rightarrow_\ell, (s_0), \mathbb{CF}(s_0)) = \{s_0\}$$
We can define a homomorphism from $s_0$ to $s_0$ using the identity function: 
$$\forall a \in \cfgnt{L}_0^\rightarrow ( h(a) = a )$$ 
Because the only constraints in the heap are $\mathit{true}$, the heap constraint evaluates to $\mathit{true}$. Since $phi_0$ also evaluates to $\mathit{true}$, the expression $\mathbb{S}(\phi_0 \wedge \mathbb{HC}(s_0 \rigtharrow_h s_0 ) ) $ must evaluate to true. Thus, any state in the feasible set must be represented by $s_0$: :
$$s_0 \in \mathbb{FS}(\rightarrow_\ell,s_0, (\eta_0\ e_0\ k_0) ) \Rightarrow s_0 \sqsubset s_0$$
Furthermore, since every reference points to a single place, there is only one possible represented heap. Thus:
$$ \{s_0\} = \mathbb{FS}(\rightarrow_\ell,s_0, (\eta_0\ e_0\ k_0) )$$
Since $s_0$ is the only represented heap, and since we know $s_0$ is in the feasible set, 
$$s_0 \sqsubset s_0 \Leftrightarrow s_0 \in \{s_0\}$$
We have now shown that $s_0 \cong \mathbb{FS}(\rightarrow_\ell, (s_0), \mathbb{CF}(s_0))$ for an arbitrary initial state $s_0$. Since every feasible state sequence starts with an initial state, we now know that:
 $$\mathit{last}(\Pi_1^s) \cong \mathbb{FS}(\rightarrow_\ell, \mathit{first}(\Pi_1^s), \mathbb{CF}(\Pi_1^s) ) $$

Inductive step: If summary state $s_s$ is exact, then any state $s_s^\prime$ such that $s_s \rightarrow_s s_s^\prime$ is also exact. Suppose $s_s$ has the form for a field read, field write, or reference compare rule. By Lemmas \ref{lem:access}, \ref{lem:write}, and \ref{lem:compare}, $s_s^\prime$ will also be exact.
Suppose $s_s$ is accepted by the "new" rule. In this case, the new reference points to the new location on condition true, so it's obvious that $s_s$ represents all of the proper lazy states, and the existence of any infeasible lazy states represented by $s_s^\prime$ would imply that $s_s$ is not exact.
For all the other rules, the L and R functions and $\phi$ are unchanged, and the rules for  $\eta$, $e$, and $k$ are exactly the same between the lazy and summary machines, so there is a bijective mapping between the represented states in $s_s$ and $s_s^\prime$.
Thus, in all cases, if $s_s$ is exact, then $s_s^\prime$ is also exact.

We have now shown that any feasible state sequence $\Pi_n^s$ is exact if the sub-sequence $\Pi_{n-1}^s$ is exact.

Combining the result from the inductive step with the result from the base case, we can now say with certainty that for all $n$,

$$\mathit{last}(\Pi_n^s) \cong \mathbb{FS}(\rightarrow_\ell, \mathit{first}(\Pi_n^s), \mathbb{CF}(\Pi_n^s) ) $$

\end{proof}

\begin{corollary}
For any given initial state, the set of possible control flow sequences under the lazy transition relation is exactly the set of possible control flow sequences under the summary transition relation.
\end{corollary}

\begin{corollary}
For any given initial state, the number of final summary states is exactly the number of possible control flow sequences.
\end{corollary}

%\begin{corollary}
%For any given initial state, the set of solutions to the constraints in the final summary states provides an optimal set of concrete test inputs. There is no smaller set that will exercise every possible control flow sequence.
%\end{corollary}

%proof: the global invariant is a constraint equation over the initial heap. That is to say, when you solve it, it assigns an integer to every variable. Those variables are references. Thus, solving the constraint equation gives you the location that each reference in the initial heap pointed to. 
%problem: Where the references pointed is only half of the problem. We also need to know which references were stored in which fields of which locations at the beginning of the program. This would not be hard to do - if we kept track of the initial heap as we created it, separate from the active heap, it should work - however, this is unimplemented
