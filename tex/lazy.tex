\section{Generating Heap Summaries}

\subsection{Initialization of Symbolic References}

In this section we present the Javalite rewrite rules for the concrete
as well as summary initialization of symbolic references. The
initialization rules are defined on the bi-partite graph consisting of
references and locations. The lazy initialization of symbolic
references consists of three key points of non-determinism where each
symbolic reference can be initialized non-deterministically to null, a
new instance of the symbolic reference, or aliases to symbolic
references of the same type previously initialized. The initialization
in GSE consists of creating branches in the execution tree for all the
non-deterministic choices. On the other hand, the heap summarization
approach creates a single branch that contains the summarization for
all the initialization in a single bi-partitate graph.

\input{initialize-lazy}
\input{summarize-precise}

\begin{figure*}[t]
\begin{center}
\begin{tabular}[c]{c|c|c|c}
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{origHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{summarizeXHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{summarizeYHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{l}
$\rho := \{ (r_1^i, r_1^i \neq r_\mathit{null}, l_1 \}$ \\
$\theta_\mathit{null} := \{ ( r_2^i = r_\mathit{null}, l_\mathit{null}) \}$\\
$\theta_\mathit{new} := \{ ( r_2^i \neq r_\mathit{null} \wedge r_2^i \neq r_1^i, l_2) \}$\\
$\theta_\mathit{alias} := \{ ( r_1^i \neq r_\mathit{null} \wedge r_2^i \neq r_\mathit{null} \wedge r_2^i = r_1^i, l_1) \}$\\
$\theta_\mathit{orig} := \{ \}$ \\
$\phi_{\mathit{1a}} := r_1^i = r_\mathit{null} $ \\
$\phi_{\mathit{1b}} := r_1^i \neq r_\mathit{null} $  \\
$\phi_{\mathit{2a}} := r_2^i = r_\mathit{null}$ \\
$\phi_{\mathit{2b}} := r_2^i \neq r_\mathit{null} \wedge r_2^i \neq r_1^i$ \\
$\phi_{\mathit{2c}} :=  r_2^i \neq r_\mathit{null} \wedge r_2^i = r_1^i $ \\
\end{tabular} \\
\end{tabular}
\end{center}
\caption{initialize this.x and this.y}
\label{fig:initHeap}
\end{figure*}




%\resizebox{3.4}{3.3}{\input{../figs/examples/origHeap.pdf_t}}

The initialization rules are invoked when an uninitialized field in a
symbolic reference is accessed. The function $\mathbb{UN}(\cfgnt{L},
\cfgnt{R}, \cfgnt{r}, \cfgnt{f}) = \{\cfgnt{l}\ ...\}$ returns
constraint-location pairs in which the field $\cfgnt{f}$ is
uninitialized:
\[
\begin{array}{rcl}
\mathbb{UN}(\cfgnt{L}, \cfgnt{R}, \cfgnt{r}, \cfgnt{f}) & = &\{ \lp\phi\ \cfgnt{l}\rp \mid \lp \phi\ \cfgnt{l}\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp  \wedge \\
& & \ \ \ \ \exists \phi^\prime \lp \lp \phi^\prime\ \cfgnt{l}_\mathit{un}\rp  \in \cfgnt{L}\lp \cfgnt{R}\lp l,\cfgnt{f}\rp\rp \wedge \\
& & \ \ \ \ \ \ \ \ \mathbb{S}\lp \phi \wedge \phi^\prime \rp\rp\}\\
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is
satisfiable. Intutively, for the reference, $\cfgnt{r}$, it constructs
the set, $\theta$, that contains all contraint-location pairs that
point to the field $\cfgnt{f}$ and $\cfgnt{f}$ points to
$\cfgnt{l}_\mathit{un}$. The cardinality of the set, $\theta$ is never
greater than one in GSE and the constraint is always satisfiable
because all constraints are constant. This property is relaxed in GSE
with heap summaries.

The rules in~\figref{fig:lazyInit} present the rewrite rules for the
concrete initialization of symbolic heap objects.  These rules are
invoked until a fix pointed is reached. 

The initialize (null) rewrite rule in~\figref{fig:lazyInit} first
checks that the field, $\cfgnt{r}$ is uninitialized. The fresh method
returns a new input heap reference from the partition 



