A recent trend in the analysis of object-oriented programs is the
modeling of references as sets of guarded values, enabling multiple
heap shapes to be represented in a single state.  A fundamental
problem with using these guarded value sets is the inability to
generate test inputs in a manner similar to symbolic execution based
analyses.
%is the creation of test inputs for
%program analyses that accept symbolic reference input
%parameters.
Although several solutions have been proposed, none have been proven
to be sound and complete with respect to the heap properties provable
by generalized symbolic execution (GSE). This work presents a method for initializing input references
in a symbolic input heap using guarded value sets that exactly
preserves GSE semantics. A correctness proof for the initialization
scheme is provided with a proof-of-concept implementation. Results from an empirical evaluation on a common set of \gsetxt{} data structure benchmarks show an increase in the
size and number of analyzed heaps over existing GSE
representations. The initialization technique can be used to ensure
that guarded value set based symbolic execution engines operate in a
provably correct manner with regards to symbolic references as well as
provide the ability to generate concrete heaps that serve as test
inputs to the program.


%A fundamental challenge of using symbolic execution for software analysis is the treatment of dynamically allocated data. Existing techniques either underapproximate the space of possible inputs or are computationally infeasible. For example, dynamic symbolic execution (DSE) handles symbolic dereferencing by substituting in a value from a valid concrete execution. Generalized symbolic execution (GSE) initiates a new search path for every possible aliasing configuration. This paper introduces a method for de-referencing and manipulating values in a true block-box symbolic input heap that overcomes the limitations of previous methods. The symbolic heap supports arbitrary recursive data structures and captures all possible heaps that follow a common control flow path. Computation of complex preconditions and postconditions is supported, as well as automatic generation of test inputs. An evaluation of a proof-of-concept implementation in the Java Pathfinder framework is presented to demonstrate the computational feasibility of the approach over several classical symbolic execution benchmarks.

