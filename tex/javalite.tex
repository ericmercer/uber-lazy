\section{Background}
\subsection{Javalite}
We present our summary heap algorithm using Javalite, an
executable formalization of a Java-like language~\cite{saints-MS}. Javalite retains 
the essence of Java and other object-oriented languages with formalizations 
in both PLT Redex and Coq so that the outcome of any program has a precise
and deterministic meaning.

Javalite is a syntactic machine defined as rewrites on a string.  The
semantics are small-step using the CEKS model with a (C)ontrol string
representing the expression being evaluated, an (E)nvironment for
local variables, a (S)tore for the heap, and a (K)ontinuation for what
is to be executed next.  In this work we change the semantics of the original
 Javalite machine and its machine syntax to represent (i) generalized
symbolic execution~\cite{GSE03}, and (ii) the summary heap algorithm
presented in this work.

The surface syntax (input) for Javalite is shown 
in~\figref{fig:surface-syntax}, and the machine syntax (state)
in~\figref{fig:machine-syntax}. Terminals are in bold face while
non-terminals are italicized. Ellipses indicate zero or more
repetitions. Tuples omit the commas for compactness. The language
itself uses s-expressions for convenience.

\input{surface-syntax}
\input{machine-syntax}

A Javalite program, $\cfgnt{P}$, is a registry of classes, $\mu$, with
a tuple indicating a class, $\cfgnt{C}$, and a method, $\cfgnt{m}$,
where execution starts. The only primitive type in Javalite is
Boolean. Classes have fields, $([\cfgnt{T}\ \cfgnt{f}]\ ...)$, and
methods, $(\cfgnt{M}\ ...)$. Methods are limited to a single
parameter in our Javalite machine. Expressions, $\cfgnt{e}$, are 
equivalent to a CEKS machine's control string, 
%somewhat typical
where $\cfgt{:=}$ indicates assignment, $\cfgt{=}$ indicates comparison,
and $\cfgt{\$}$ represents the dot-operator for field access. The dot-operator
for method invocation is represented by $\cfgt{@}$. There is no explicit return
statement in Javalite; rather, the value of the last expression is
used as the return value. A variable is always indicated by \cfgnt{x}
and a value by \cfgnt{v}. A value can be a reference in the heap,
$\cfgnt{r}$, or any of the special values shown in~\figref{fig:surface-syntax}. 
We assume that only
type correct programs are given as input to the machine.

The state of the Javalite machine (\figref{fig:machine-syntax}),
$\cfgnt{s}$, includes the program registry, $\mu$\footnote{The registry $\mu$
  is implied in the rewrite rules and not included in the state tuples.},
  and a pair of functions defining the heap
$\lp\cfgnt{L}\ \cfgnt{R}\rp$, which is the store. The state also
includes a constraint,
$\phi$, defined over references in the heap, the environment, $\eta$,
for local variables, and the continuation $\cfgnt{k}$. The more
complex structures, such as the environment, are defined as lists which
start with empty, \cfgnt{mt}. The rewrite rules that define the
semantics treat these lists as partial functions. As such,
$\eta(\cfgnt{x}) = \cfgnt{r}$ is the reference $\cfgnt{r}$ mapped to the variable
$\cfgnt{x}$. The notation $\eta^\prime = \eta[\cfgnt{x} \mapsto
  \cfgnt{v}]$ defines a new partial function $\eta^\prime$ that is
the same as $\eta$ except that the variable $\cfgnt{x}$ now maps to
$\cfgnt{v}$.

The continuation $\cfgnt{k}$ helps accomplish the small-step semantics
by indicating where the hole, $\cfgt{*}$, is located, by storing
temporary computations, and by keeping track of the next
computation. For example, the continuation
$\lp\cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp$ indicates
that the machine is currently computing the expression for the object
reference on which the field $\cfgnt{f}$ is going to be accessed. Once
the field access is complete, the machine continues with $\cfgnt{k}$.




