\section{Generating Summary Heaps}
\label{sec:precise}

In this section we present the rewrite rules for the $\rsym$ relation. 
There are three sets of rewrite rules specific to the summary
heap algorithm: (i) rules to initialize symbolic
references, (ii) field access and write rules, and (iii) rules
to check equality and inequality of references. These rules
form the core of the summary heap algorithm.

\subsection{Initialization of Symbolic References}

During initialization of symbolic references in the $\rgse$ relation,
non-determinitic choices are introduced into the search to
account for initiaization of the reference to $\mathit{null}$, a new instance of the 
object, and to any type compatible object previously
initialized. In contrast, initialization rules for the $\rsym$ relation are 
defined on the bipartite graph consisting of references and locations,
and create a single branch containing a summarization of
all the initializations in a single graph.

\input{summarize-precise-incomplete}

\begin{figure*}
\begin{tabular}[c]{l}
\scalebox{1.0}{\usebox{\boxPI}} \\
\end{tabular}
\caption{The summary machine, $s ::= \lp\cfgnt{L}\ \cfgnt{R}\ \cfgnt{r}\ \cfgnt{f}\ \cfgnt{C}\rp$, with $s\rsum^*s^\prime =  s \rsum \cdots \rsum s^\prime \rsum s^\prime$.}
\label{fig:symInit}
\end{figure*}

The initialization rules are invoked whenever an uninitialized field in a
symbolic reference is accessed. The function $\mathbb{UN}(\cfgnt{L},
\cfgnt{R}, \cfgnt{r}, \cfgnt{f}) = \{\cfgnt{l}\ ...\}$ returns
constraint-location pairs in which field $\cfgnt{f}$ is
uninitialized:
\[
\begin{array}{rcl}
\mathbb{UN}(\cfgnt{L}, \cfgnt{R}, \cfgnt{r}, \cfgnt{f}) & = &\{ \lp\phi\ \cfgnt{l}\rp \mid \lp \phi\ \cfgnt{l}\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp  \wedge \\
& & \ \ \ \ \exists \phi^\prime \lp \lp \phi^\prime\ \cfgnt{l}_\mathit{un}\rp  \in \cfgnt{L}\lp \cfgnt{R}\lp l,\cfgnt{f}\rp\rp \wedge \\
& & \ \ \ \ \ \ \ \ \mathbb{S}\lp \phi \wedge \phi^\prime \rp\rp\}\\
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is
satisfiable. Intutively, for reference $\cfgnt{r}$, this function constructs
the set, $\theta$ containing all contraint-location pairs that
point to field $\cfgnt{f}$ and $\cfgnt{f}$ points to
$\cfgnt{l}_\mathit{un}$.

% The cardinality of the set, $\theta$ is never
%greater than one in GSE and the constraint is always satisfiable
%because all constraints are constant. This property is relaxed in GSE
%with heap summaries.

The rewrite rule to initialize a heap in the summary heap algorithm
is shown in~\figref{fig:symInit}. Given the unitialized set
$\mathbb{UN}$ for field $f$, the $\mathit{min}_l$ function returns
$(\phi_x\ \cfgnt{l}_x)$ based on a lexical ordering of uninitialized locations
in $\Lambda$. The init$_r$ method returns a new input reference $\cfgnt{r}_f$,
while the fresh$_f$ returns a new location of type $C$. The set $\rho$
contains the set of reference-location pairs, $(\cfgnt{r}_a\ \cfgnt{l}_a)$, the
field being initialized may alias. A pair $(\cfgnt{r}_a\ \cfgnt{l}_a)$ is contained
in the set $ \rho $ if the following conditions hold: (i) $\cfgnt{r}_a$ is
part of the input references initialized in the summary heap, (ii)
$\cfgnt{r}_a$ is in the pre-image of $\cfgnt{l}_a$, and (iii) the type 
of $\cfgnt{l}_a$ is the same as the type of the field being initialized.

There are three constraint-location pair sets that correspond to the
non-deterministic choices in GSE: (a) $\theta_\mathit{null}$ contains
a constraint $\cfgnt{r}_f = \cfgnt{r}_\mathit{null}$ paired with the location
$\cfgnt{l}_\mathit{null}$, (b) \sjp{something is not right in this choice}
$\theta_\mathit{new}$ creates a pair with a
constraint representing the fact that $\cfgnt{r}_f$ is not null and it does 
not alias any reference in set $\rho$ under and a newly created location 
$\cfgnt{l}_f$, and (c) 
$\theta_\mathit{alias}$ where for each element in the set $(\cfgnt{r}_a\ \cfgnt{l}_a)
\in \rho$ it creates a constraint stating that $\cfgnt{r}_f$ is not null, points to
$\cfgnt{r}_a$, and does not point to any reference contained in $(\cfgnt{r}_a^\prime\ 
\cfgnt{l}_a^\prime) \in \rho$ such that $\cfgnt{r}_a < \cfgnt{r}_a^\prime$ based on a lexical
ordering of initialized references. Additionally,
$\theta_\mathit{orig}$ allows for the possibility that the field
continues to remain uninitialized since the heap is symbolic.
\sjp{The last statement seems to jump out since we have not been
talking about the heap being symbolic (have we?)} We refer
to initialization in the summary machine as conditional
initialization \sjp{Not sure why we say this - what does it mean
to the reader?}. Finally, the fields of the reference $\cfgnt{r}_f$ are marked
as uninitialized. In the post condition of the rule, the reference
$\cfgnt{r}_f$ points to $\theta$ which contains the union of all the
constraint location pairs sets, and the field $f$ points to the new
reference $\cfgnt{r}_f$ in the summary heap.

\begin{comment}
 Note that the summarize rule invoked repeatedly until
the set of unitialized constraint location pairs for field $f$ is
empty. In other words the set $\Lambda$ is empty. This consititutes
the summarize end rule in~\figref{fig:symInit}.
\end{comment}

\begin{figure*}[t]
\begin{center}
\begin{tabular}[c]{c|c|c|c}
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{origHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{summarizeXHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{c}
\scalebox{0.81}{\input{summarizeYHeap.pdf_t}} \\
\end{tabular} &
\begin{tabular}[c]{l}
$\rho := \{ (\cfgnt{r}_1^i\ \cfgnt{l}_1 \}$ \\
$\theta_\mathit{null} := \{ ( \cfgnt{r}_2^i = \cfgnt{r}_\mathit{null}\ \cfgnt{l}_\mathit{null}) \}$\\
$\theta_\mathit{new} := \{ ( \cfgnt{r}_2^i \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_2^i \neq \cfgnt{r}_1^i\ \cfgnt{l}_2) \}$\\
$\theta_\mathit{alias} := \{ ( \cfgnt{r}_1^i \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_2^i \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_2^i = \cfgnt{r}_1^i\ \cfgnt{l}_1) \}$\\
$\theta_\mathit{orig} := \{ \}$ \\
$\phi_{\mathit{1a}} := \cfgnt{r}_1^i = \cfgnt{r}_\mathit{null} $ \\
$\phi_{\mathit{1b}} := \cfgnt{r}_1^i \neq \cfgnt{r}_\mathit{null} $  \\
$\phi_{\mathit{2a}} := \cfgnt{r}_2^i = \cfgnt{r}_\mathit{null}$ \\
$\phi_{\mathit{2b}} := \cfgnt{r}_2^i \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_2^i \neq \cfgnt{r}_1^i$ \\
$\phi_{\mathit{2c}} :=  \cfgnt{r}_2^i \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_2^i = \cfgnt{r}_1^i $ \\
\end{tabular} \\
(a) & (b) & (c) & (d) \\
\end{tabular}
\end{center}
\caption{An example that initializes $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$ and $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$. (a) Initial heap structure. (b) After $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$ is initialized. (c) After $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$ is initialized. (d) Constraint sets from the summary rule and constraints on the edges.}
\label{fig:initHeap}
\end{figure*}

We visualize the initialization process in~\figref{fig:initHeap}. The
graph in~\figref{fig:initHeap}(a) represents the initial heap. The
references with the superscript $s$ indicates that it is a local
reference. In~\figref{fig:initHeap} $\cfgnt{r}_0^s$ represents a local
reference for the $\cfgt{this}$ reference which has two fields $x$
and $y$ of the same type; reference $\cfgnt{r}_0^s$ points to location
$\cfgnt{l}_0$. Note that when no constraint is specified in the graphs, then
there is an implicit $\mathit{true}$ constraint, for example, $\cfgnt{r}_0^s$
points to $\cfgnt{l}_0$ on the constraint $\mathit{true}$. The fields $x$ and
$y$ point to the uninitialized reference $\cfgnt{r}_\mathit{un}$.

% The reference $\cfgnt{r}_\mathit{un}$ points to the uninitialized location
%$\cfgnt{l}_\mathit{un}$ on the $\mathit{true}$ constraint.

The graph in~\figref{fig:initHeap}(b) represents the summary heap
after the initialization of the $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$ field while
the graph in~\figref{fig:initHeap}(c) represents the symbolic heap
summary after the initialization of the $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$ field
following the initialization of $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$. The list
in~\figref{fig:initHeap}(d) represents the various sets constructed in
the summarize rule during the initialization of $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$. We
also define values of constraints used as labels in the graph.

The access on $\cfgnt{l}_0.x$ creates a new input reference $\cfgnt{r}_1^i$ in the
summary heap shown in~\figref{fig:initHeap}(b). The reference $\cfgnt{r}_1^1$
points to the $\cfgnt{l}_\mathit{null}$ location under the constraint that
$\cfgnt{r}_1^i$ is null: $\phi_{1a} := \cfgnt{r}_1^i = \cfgnt{r}_\mathit{null}$. The reference
$\cfgnt{r}_1^i$ points to the location $\cfgnt{l}_1$ under the constraint that $\cfgnt{r}_1^i$
is not $\mathit{null}$ $\phi_{1b} :=\cfgnt{r}_1^i \neq \cfgnt{r}_\mathit{null}$. The
location $\cfgnt{l}_1$ represents a fresh location of type $C$ is created on
the heap such that $C$ is type of $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$.

Following initialization to $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$, when
$\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$ is initialized, the resulting summary heap is shown
in~\figref{fig:initHeap}(c). The set $\rho$ shown
in~\figref{fig:initHeap}(d) contains the potential aliases for
 $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$ which is location $\cfgnt{l}_1$ ($\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$). The
constraint location $\theta$ sets represents the initialization
choices for $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$. The new input reference $\cfgnt{r}_2^i$ for
$\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$ points to (a) location $\cfgnt{l}_\mathit{null}$ under the constraint
$\phi_{2a} := \cfgnt{r}_2^i = \cfgnt{r}_\mathit{null}$, (b) location $\cfgnt{l}_2$ under the
constraint $\phi_{2b} := \cfgnt{r}_2^i \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_2^i \neq
\cfgnt{r}_1^i$ that states that $\cfgnt{r}_2^i$ is not null and does not alias
$\cfgnt{r}_1^i$, and (c) location $\cfgnt{l}_1$ under the constraint $\phi_{2c} :=
\cfgnt{r}_2^i \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_2^i = \cfgnt{r}_1^i$ that states $\cfgnt{r}_2^i$
is not null and \emph{does} alias $\cfgnt{r}_1^i$.


\subsection{Reading and Writing References}
\input{precise-fig-incomplete}

\begin{figure*}[t]
\begin{center}
\setlength{\tabcolsep}{60pt}
\hspace*{-35pt}
\begin{tabular}[c]{cc}
\scalebox{1.0}{\usebox{\boxPFAFW}} & 
%\scalebox{0.91}{\input{faYHeap.pdf_t}} &
\scalebox{0.91}{\input{fwXHeap.pdf_t}} \\ \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Field read and write relations with an example heap. (a) Field-access, $\rsym^\mathit{A}$, and field-write, $\rsym^\mathit{W}$, rewrite rules for the $\rsym$ relation. (b) The final heap after $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\ \cfgt{:=}\ \lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp\rp$.}
\label{fig:fHeap}
\end{figure*}

There are two rewrite rules in~\figref{fig:fHeap}(a), one for reading
the value of a field (field-access) and the other when we write to a
field (field-write). In both the field rewrite rules we first check we
perform is whether there exists a constraint location pair for the $r$
being accessed such that the location is not null and the constraint
when conjuncted with the global constraint is satisfiable. Next we
extract all possible constraints under which $r$ points to a null
location such that the constraint is satisfiable under the current
global constraint, $\phi_g$. The negation of these constraints are
added to the global constraint to create a new global constraint
$\phi_g^\prime$. The update to the global constraint ensures that
access or write of the field $f$ happens only on non-null
locations. There are rewrite rules for accessing and writing to fields
on null locations where it leads the current program execution state
to an error state. The rewrite rules for the accessing and writing to
null locations are presented in the supplemental document.

In the field-access rewrite rule in~\figref{fig:fHeap}(a) after the
non-nullness check we extract the The type $C$ of the field is
extracted and invoke the summarize rewrite rule
in~\figref{fig:symInit} that performs the initialization of the field
if it points to uninitialized locations. Once the initialization is
complete, we create a new local reference $r^\prime$. An important
property of the references in the bi-partiate graph is that they are
\emph{immutable}. Hence we create a new local reference and assign it
to the initialized reference, and return the local reference. In order
to de-reference a field $r.f$ we define a helper function which is
called the value set.

\input{value-set-def}

In the post-condition of the rewrite rule we assign
the value set of input reference $r$ to the local reference $r^\prime$
and return the local reference $r^\prime$ in the next state.

Consider the graph shown in~\figref{fig:fHeap}(b) the reference
$\cfgnt{r}_2^i$ is created during the initialization of $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$. The
reference that is returned during the access of the field, however, is
$\cfgnt{r}_3^s$. The reference $\cfgnt{r}_3^s$ points to the value set of $\cfgnt{r}_2^i$
which are: $(\phi_{2a}\ \cfgnt{l}_\mathit{null})$, $(\phi_{2b}\ \cfgnt{l}_2)$, and
$(\phi_{2c}\ \cfgnt{l}_1)$. The values of the constraints $\phi_{2a}$,
$\phi_{2b}$, and $\phi_{2c}$ are defined in~\figref{fig:initHeap}(d).

The field-write rewrite rule in~\figref{fig:fHeap}(a) after the
non-nullness check we We look up the value of the base reference in
the environment $\eta(x)$.  The reference $\cfgnt{r}_x$ is the base pointer
whose field, $\cfgnt{r}_\mathit{curr}$ is being written to to while the
reference $r$ is the target reference. The set $\Psi_x$ contains
tuples $(\phi\ l\ \cfgnt{r}_\mathit{curr})$ of constraints, locations, and
references. These tuples represent access chains leading from $\cfgnt{r}_x$ to
the reference of the field, $\cfgnt{r}_\mathit{curr}$. The goal is to
overwrite the $\cfgnt{r}_\mathit{curr}$ references with the target
references. Since the target of the write is $r$, we first check that
the location constraint pairs of $\cfgnt{L}(r)$ are satisfiable when accessed
through the $\cfgnt{r}_x$ chain. This is accomplished by the strengthening
function.

\input{st-def}

Note that the write is conditional. In the case that $\phi$ is true
then $\cfgnt{r}_\mathit{curr}$ will point to the constraint location pairs of
$\cfgnt{L}(\cfgnt{r})$ while if $\phi$ is false then $\cfgnt{r}_\mathit{curr}$ will continue
to point to the constraint location pair it is currently pointing to.
Again since the references are immutable we create a new reference for
each $\cfgnt{r}_\mathit{curr}$ and point them to the target constraint
location pairs.

Consider the example shown in~\figref{fig:fHeap}(b) where we assign
$\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\ \cfgt{:=}\ \lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp\rp$. Note that
in~\figref{fig:initHeap}(c) $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{x}\rp$ is represented by
$\cfgnt{r}_1^i$. After applying the field-write rule the reference $\cfgnt{r}_1^i$ is
replaced by the fresh reference $\cfgnt{r}_4$ which now points to target
 $\lp\cfgt{this}\  \cfgt{\$}\ \cfgnt{y}\rp$ represented by $\cfgnt{L}(\cfgnt{r}_2^i)$.


\begin{comment}
\begin{figure}[t]
\begin{center}
\begin{tabular}[c]{l}
$\Psi_x = \{ (true\ \cfgnt{l}_0\ \cfgnt{r}_1^i) \}$\\
$ST (\cfgnt{L}, \cfgnt{r}_3^s, \phi, \phi_g)$ \\
$\theta = \{ (\phi_{2a}\; \cfgnt{l}_\mathit{null} ) (\phi_{2b}\; \cfgnt{l}_2) (\phi_{2c}\; \cfgnt{l}_1) \}$\\
$ST(\cfgnt{L}, \cfgnt{r}_0, \phi, \phi_g)$\\
$\theta = \{ \}$\\
\end{tabular}
\end{center}
\caption{FIXME: When will I get a caption}
\label{fig:faHeapSets}
\end{figure}
\end{comment}



\subsection{Equality and InEquality of References}
\input{precise-eq}

\begin{figure*}
\begin{center}
\begin{tabular}[c]{c}
\scalebox{1.0}{\usebox{\boxPEQ}} \\
% & \usebox{\boxPEX} \\ \\
%(a) & (b) \\
\end{tabular}
\end{center}
\caption{The reference compare rewrite rule for both the true, $\rsym^\mathit{E}$, and false, $\rsym^\mathit{E^\prime}$ outcomes.}
\label{fig:eqs}
\end{figure*}



\newsavebox{\boxPEX}
\savebox{\boxPEX}{
\begin{tabular}[c]{l}
$\cfgnt{L}(\cfgnt{r}_1^i) = \{ (\phi_{1a}\; \cfgnt{l}_\mathit{null})\; (\phi_{1b}\; \cfgnt{l}_1) \}$ \\
$\cfgnt{L}(\cfgnt{r}_2^i) = \{ (\phi_{2a}\; \cfgnt{l}_\mathit{null}),\; (\phi_{2b}\; \cfgnt{l}_2),\; (\phi_{2c}\; \cfgnt{l}_1) \} $\\
  $\theta_0 = \{ \} $\\
$\theta_1 = \{ \phi_{2b}\} $\\ \hline
Equals true \\
$\theta_\alpha = \{ (\phi_{1a}\; \wedge\; \phi_{2a} ) (\phi_{1b}\; \wedge\; \phi_{2c} ) \}$\\
$\phi^\prime = \mathit{true} \wedge [ (\phi_{1a}\; \wedge\; \phi_{2a} )\vee (\phi_{1b}\; \wedge\; \phi_{2c} ) ] \wedge \neg\phi_{2b} $\\ \hline
Equals false \\
$\theta_\alpha = \{ (\phi_{1a}\; \implies\; \neg\phi_{2a} ) (\phi_{1b}\; \implies\; \neg\phi_{2c} ) \}$\\
$\phi^\prime = \mathit{true} \wedge  (\phi_{1a}\; \implies\; \neg\phi_{2a} )\wedge (\phi_{1b}\; \implies\; \neg\phi_{2c} )  \wedge \phi_{2b} $\\ \hline
\end{tabular}}


The rewrite rules to compare two references in the symbolic summary
heap are shown in~\figref{fig:eqs}. The equals references-true rewrite
rule returns true when two references $\cfgnt{r}_0$ and $\cfgnt{r}_1$ \emph{can} be
equal. In GSE semantics checking equality of references is a simple
comparision of two concrete object references. In the symbolic summary
heap, however, we compare sets of constraint location pairs pointed to
by each reference to determine if they could be equal. 

Consider the equals reference-true rewrite rule
in~\figref{fig:eqs}. In order to check equality we construct three
sets of constraints. For all constraint location pairs $(\phi_0\ \cfgnt{l}_0)
\in \cfgnt{L}(\cfgnt{r}_0)$ and $(\phi_1\ \cfgnt{l}_1) \in \cfgnt{L}(\cfgnt{r}_1)$ such that $\cfgnt{l}_0$ and $\cfgnt{l}_1$
are the same ($\cfgnt{l}_0 = \cfgnt{l}_1$) we create conjunctions of the constraints
$\phi_0 \wedge \phi_1$ and add them to set $\Phi_\alpha$. Intutively,
$\Phi_\alpha$ contains all constraints under which $\cfgnt{r}_0$ and $\cfgnt{r}_1$ may
point to the same location in the symbolic summary heap. The second
set, $\Phi_0$, contains constraints under which the reference $\cfgnt{r}_0$
points corresponding locations such that the reference $\cfgnt{r}_1$
\emph{does not} point to those locations under any
constraint. Finally, the set, $\Phi_1$, contains constraints under
which $\cfgnt{r}_1$ points to corresponding locations and $\cfgnt{r}_0$ \emph{does
  not} point to those locations under any constraint.

We use the three sets of constraints to update the current global heap
constraint $\phi_g$ and create a new global heap constraint
$\phi_g^\prime$. We add to $\phi_g$ the disjunction of the constraints
in $\Phi_\alpha$ to indicate that if any of the constraints are
satisfiable, then references $\cfgnt{r}_0$ and $\cfgnt{r}_1$ can be
equal. Furthermore, we had to the global heap constraint,
$\phi_g^\prime$, the conjunctions of negations to the constraints in
$\Phi_0$ and $\Phi_1$. This indicates for locations that are not
common to the references, the negations of their constraints are
satisfiable. Before the rewrite rule returns true we check the
satisfiability of the updated global heap constraint.

Consider the example in~\figref{fig:initHeap}(c). In order to to check
if $\cfgnt{r}_1^i$ and $\cfgnt{r}_2^i$ are equal we first get the constraint location
pairs associated with each of the references:
\[
\cfgnt{L}(\cfgnt{r}_1^i) = \{ (\phi_{1a}\; \cfgnt{l}_\mathit{null})\; (\phi_{1b}\; \cfgnt{l}_1) \} 
\]
\[
\cfgnt{L}(\cfgnt{r}_2^i) = \{ (\phi_{2a}\; \cfgnt{l}_\mathit{null})\; (\phi_{2b}\; \cfgnt{l}_2)\; (\phi_{2c}\; \cfgnt{l}_1) \} \\
\]
\noindent{The three constraint sets are:} 
\[
\Phi_\alpha = \{ (\phi_{1a}\; \wedge\; \phi_{2a} ) (\phi_{1b}\; \wedge\; \phi_{2c} ) \}\;
\Phi_0 = \{ \}\; \Phi_1 = \{ \phi_{2b}\} \\
\]
\noindent{Finally the global constraint is} 
\[
\phi^\prime = \mathit{true} \wedge [ (\phi_{1a}\; \wedge\; \phi_{2a} )\vee (\phi_{1b}\; \wedge\; \phi_{2c} ) ] \wedge \neg\phi_{2b} 
\]
\noindent{The equals references-false is the logical dual of the
  reference-true rewrite rule. The references-false is shown
  in~\figref{fig:eqs}.}
