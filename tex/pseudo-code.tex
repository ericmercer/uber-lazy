\section{Pseudo-code}
\figref{fig:surface-syntax} defines the surface syntax for the
Javalite language \cite{saints-MS}. The \figref{fig:machine-syntax} is
the machine syntax. The semantics of Javalite is syntax based and
defined as rewrites on a string. The semantics use a CEKS machine
model with a (C)ontrol string representing the expression being
evaluated, an (E)nvironment for local variables, a (K)ontinuation for
what is to be executed next, and a (S)tore for the heap. This paper
only defines salient features of the language and machine relevant to
understanding the new algorithm.

\input{surface-syntax}
\input{machine-syntax}

%\item $n$ are numbers, and the set of all positive natural numbers is $\mathbb{N}^+$.
This paper uses a standard definition of constraints $\phi \in \Phi$
assuming all the usual relational operators and connectives. The heap
is a labeled bipartite graph consisting of references $R$ and
locations $L$ in the store. The functions $R$ and $L$ are defined for convenience
in manipulating the labeled bipartite graph.
\begin{itemize}
\item $R(l,f)$ maps location-field pairs from the store to a reference in $R$; and
\item $L(r)$ maps references to a set of location-constraint pairs in the store.
\end{itemize}
A reference is a node that gathers the possible store locations for an
object during symbolic execution. Each store location is guarded by a
constraint that determines the aliasing in the heap. Intuitively, the
reference is a level of indirection between a variable and the store,
and the reference is used to group a set of possible store locations
each predicated on the possible aliasing in the associated constraint.
For a variable (or field) to access any particular store location
associated with its reference, the corresponding constraint must be
satisfied.

Locations are boxes in the graphical representation and indicated with
the letter $l$ in the math. References are circles in the graphical
representation and indicated with the letter $\cfgnt{r}$ in the
math. The special symbol $\bot$ is an uninitialized reference. Edges
from locations are labeled with field names $\cfgnt{f}$. Edges from
the references are labeled with constraints $\phi \in \Phi$ (it is
assumed that $\Phi$ is a power set over individual constraints and
$\phi$ is a set of constraints for the edge).

The function $\mathbb{VS}(L,R,\phi_g,r,f)$ constructs the value-set given a
heap, reference, and desired field:
\[
\begin{array}{rcl}
  \mathbb{VS}(L,R,\phi_g,r,f) & = & \{(l^\prime\ \phi\wedge\phi^\prime) \mid \\
  & & \ \ \ \ \exists l\ ((l\ \phi) \in L(r)\ \wedge \\
  & & \ \ \ \ \ \ \ \ \exists r^\prime \in R(l,f) ( \\
  & & \ \ \ \ \ \ \ \ \ \ \ \ (l^\prime\ \phi^\prime) \in L(r^\prime)\ \wedge\\
  & & \ \ \ \ \ \ \ \ \ \ \ \ \mathbb{S}(\phi\wedge\phi^\prime\wedge \phi_g)))\}
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is satisfiable.

The strengthen function $\mathbb{ST}(L,r,\phi^\prime)$ strengthens every
constraint from the reference $r$ with $\phi^\prime$ and keeps only location-constraint
pairs that are satisfiable after this strengthening:
\[
\begin{array}{rcl} 
\mathbb{ST}(L,r,\phi^\prime) & = & \{ (l\ \phi\wedge\phi^\prime) \mid 
(l\ \phi)\in L(r)\wedge\mathbb{S}(\phi\wedge\phi^\prime) \}
\end{array}
\]


\input{machine-rules}
