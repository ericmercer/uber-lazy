\section{Introduction}

In recent years symbolic execution has provided the basis for various 
software testing and analysis techniques. Symbolic execution
systematically explores the program execution space using
symbolic input values, and for each explored path, computes
constraints on the symbolic inputs to create a \emph{ path condition}.
The set of path conditions computed by
symbolic execution characterize the observed program execution
behaviours and have been used as an enabling technology for various
applications, e.g., regression
analysis~\cite{backes:2012,Godefroid:SAS11,Person:FSE08,person:pldi2011,Ramos:2011,Yang:ISSTA12},
data structure repair~\cite{KhurshidETAL05RepairingStructurally},
dynamic discovery of
invariants~\cite{CsallnerETAL08DySy,Zhang:ISSTA14}, and
debugging~\cite{Ma:2011}.

Initial work on symbolic execution largely focused on checking 
properties of programs with primitive types~\cite{clarke76TSE,King:76}.
%, e.g., integers and booleans 
%Despite recent advances
%in constraint solving technologies, improvements in
%raw computing power, and advances in reduction
%and abstraction techniques~\cite{AnandETAL2009AbsSymExe,Godefroid:POPL07}
%symbolic execution of programs of modest size containing only
%primitive types, remains challenging
%because of the large number of execution paths generated
%during symbolic analysis. 
With the advent of object-oriented languages,
% e.g., Java and C$++$, 
recent work has generalized the core ideas of symbolic execution to enable 
analysis of programs containing complex data structures with unbounded 
domains, i.e., data stored on the heap~\cite{Kiasan06,Kiasan07,GSE03}.  
These Generalized Symbolic Execution (GSE) techniques construct the 
heap in a lazy manner, deferring
materialization of objects on the concrete heap until they are needed
for the analysis to proceed. The materilization 
%accounts for various heap configurations, 
creates additional non-deterministic choice points in the symbolic
execution tree representing the feasible heap configurations.  as (a)
null, (b) instance of a new reference of a compatible class, and (c)
alias an previously initialized symbolic reference.  Symbolic
execution follows concrete program semantics for materialized heap
locations. Although this approach enables analysis of heap
manipulating programs, a large number of feasible concrete heap
configurations may be created exacerbating the well known state space
explosion problem associated with symbolic execution.

%  resulting in a large number of feasible concrete heap
%configurations, and as a result, a large number of points of
%non-determinism to be analyzed.
%, further exacerbating the state space
%explosion problem.

The goal of this work is to mitigate the state space explosion problem
in GSE by grouping multiple heaps together and only partitioning the
heaps at points of divergence in the control flow graph. To achieve
this goal, we found inspiration from recent work in the domain of
static analysis that uses sets of constraints over heap locations to
encode multiple heaps in a single representation. These sets,
sometimes known as value sets or value summaries, allow multiple heaps
to be represented simultaneously with a higher degree of precision
than afforded by traditional shape analysis techniques. Some of these
previous attempts, however, are unable to handle aliasing in heaps due
to a recursive definition of objects~\cite{..}, while others require a
set of heaps as input and are unable to initialize heaps
on-the-fly~\cite{..}. For these reasons the techniques use
over-approximations to reason about heaps and may report false
positives. Also, an update to the heap required a rewrite of the
constraint system making it prohitive for use in the context of
symbolic execution.

%The goal of this work is find a more compact representation of the heaps
%and be better able to leverage constraint solvers.
%The  But any update of the heap required a rewrite on the constraint system
%or simply was not opssible to initialize and handle the aliasing possiblities.

%The goal is to leverage that

%Research in the abstract interpretation community has taken a very
%different approach to analyzing heap manipulating programs which
%computes a summary of possible heaps.  These techniques start with an
%initial heap configuration and then using a static analysis, make
%updates to the heap following program semantics, ultimately creating
%a heap summary which represents the potential heaps resulting from
%program execution~\cite{Dillig:2011}. Because these techniques are
%based on a static analysis, the heap summaries over-approximate the
%set of feasible heap configurations.

%The primary challenge relative to heap analysis for these techniques
%is to resolve potential dependencies of local results on the global
%aliases in the heap.  Recent work addresses these issues through
%strong updates to heap locations at call sites~\cite{Dillig} and
%computation of dangerous aliases~\cite{Matosevic}. Because these
%techniques are based on a static analysis, the resulting summaries
%over-approximate the actual potential heaps.

In this work, we present a novel heap initialization and analysis
technique which takes inspiration from both GSE and existing heap
summarization techniques. The intuition behind our analysis is to
construct the heap lazily during symbolic execution but reduce the
points of non-determinism in the symbolic execution tree by analyzing
each control-flow path only once for any given set of isomorphic
heaps. To represent the exact set of feasible concrete heap structures
resulting from execution of the control-flow path, we use a heap
summary.  Our analysis improves on existing GSE approaches by reducing
the size of the symbolic execution state space explored, thereby
improving scalability of symboic execution for heap manipulating
software. It improves on existing heap summarization techniques by
enabling analysis of arbitrary recursive data structures (no initial
heap configuration is required) while avoiding the imprecision
introduced by these techniques.

\nsr{a paragraph that provides a breif summary
  of the results.. would be nice if we have numbers for lazier and
  lazier Sharp as well.}
  A preliminary evaluation of our technique
shows that it can improve the scalability of symbolic execution
of heap manipulating programs X fold over GSE-based analyses
while maintaining precision and efficiency. 

This paper makes the following contributions:
\begin{itemize}
\item{We present a novel inter-procedural analysis technique for 
symbolic execution of heap manipulating software which constructs 
a precise heap summary.}
\item{We use the JavaLite language~\cite{saints-MS} to formalize 
the algorithm for constructing and manipulating the heap summary
on-the-fly during symbolic execution.}
\item{We implement our approach in the Symbolic PathFinder tool and
empirically demonstrate that our technique improves
the scalability of symbolic execution of heap maninpulating software
over GSE, while maintaining efficiency and precision.}
\item{We prove that at any given point during symbolic execution, the symbolic 
heap represents the exact set of feasible concrete heap structures 
for the program under analysis.}
 \end{itemize}

%\nsr{needs
%  some text on the fact we use java lite to formalize the heap
%  summary, some key characteristicss of the heap such as the fact it
%  is a bipartiate graph with locations and referneces, properties of
%  the heap such as the determinism and immutability}
\nsr{Is any part of the formalism borrowed
from the dilligs? Which part are unique?}  \nsr{end on a couple
sentences about the various rules that will be talked about in the
paper}

\nsr{The reader should be convinced about our expressiveness
  claim here}

\nsr{a paragraph that provides intution on how we are a bisumulation
  with the GSE..reader should be convinced about the precision claim}

\begin{comment}
\newcommand{\Indstate}[1][1]{\State\hspace{#1\algorithmicindent}}

\begin{figure}
\begin{center}
\begin{algorithmic}[1]
\Procedure{load}{$r,f$}
\If{$r$ is initialized and $f$ is uninitialized}
\If{ $f$ has a reference type}
\State nondeterministically assign to $f$:
\State  \ \ null  %hacky way to indent.
\State \ \ non-null
\EndIf
\If{$f$ has a primitive type}
\State assign $f$ a new symbol
\EndIf
\EndIf
\If{$r$ is uninitialized}
\State nondeterministically assign to $f$:
\State  \ \ a new symbolic location  %hacky way to indent.
\State \ \ an existing symbolic location
\EndIf
\State\Return $r.f$
\EndProcedure
\end{algorithmic}
\end{center}
\caption{Lazier\# Initialization}
\end{figure}

Lazy initialization is a symbolic execution technique where memory structures are created on-demand, as they are required.
\end{comment}



