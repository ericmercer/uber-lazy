\subsection{Accessing a Field Reference}



\input{precise-fig}


\begin{figure*}[t]
\begin{center}
\setlength{\tabcolsep}{50pt}
\begin{tabular}[c]{cc}
\usebox{\boxPFAFW} & 
%\scalebox{0.91}{\input{faYHeap.pdf_t}} &
\scalebox{0.91}{\input{fwXHeap.pdf_t}} \\ \\
(a) & (b)
\end{tabular}
\end{center}
\caption{field access for this.y and field write for this.x = this.y}
\label{fig:fHeap}
\end{figure*}

There are two rewrite rules in~\figref{fig:fHeap}(a), one for field
access and the other for field write. Let us consider the rewrite rule
for field access. The first check we perform is whether there exists a
constraint location pair for the $r$ being accessed such that the
location is not null and the constraint when conjuncted with the
global constraint is satisfiable. Next we extract all possible
constraints under which $r$ points to a null location such that the
constraint is satisfiable under the current global constraint,
$\phi_g$. The negation of these constraints are added to the global
constraint to create a new global constraint $\phi_g^\prime$. The
update to the global constraint ensures that access of the field $f$
happens only on non-null locations. The type $C$ of the field is
extracted and passed to rewrite rule that performs the initialization
of the symbolic heap. The initialization rules are described earlier
in this section. 

Recall that during the initialization the rewrite rules
in~\figref{fig:symHeap} add input references that map to fields being
initialized.  Once the initialization is complete, however, we create
a new local reference $r^\prime$. An important property of the
references in the bi-partiate graph is that they are
\emph{immutable}. Hence we de-reference the initialized input
reference, assign its value to the the new local reference, and return
the local reference. In order to de-reference a field $r.f$ we define
a helper function which is called the value set.

\begin{definition}
\label{def:VS}
The function $\mathbb{VS}(L,R,\phi_g,r,f)$ constructs the value-set given a
heap, reference, and desired field:
\[
\begin{array}{rcl}
  \mathbb{VS}(\cfgnt{L},\cfgnt{R},\phi_g,\cfgnt{r},\cfgnt{f}) & = & \{(\phi\wedge\phi^\prime\ \cfgnt{l}^\prime) \mid \\
  & & \ \ \ \ \exists \cfgnt{l}\ ((\phi\ l) \in L(r)\ \wedge \\
  & & \ \ \ \ \ \ \ \ \exists \cfgnt{r}^\prime ( \cfgnt{r}^\prime = R(\cfgnt{l},\cfgnt{f})\ \wedge \\
  & & \ \ \ \ \ \ \ \ \ \ \ \ (\phi^\prime\ l^\prime) \in \cfgnt{L}(\cfgnt{r}^\prime)\ \wedge\\
  & & \ \ \ \ \ \ \ \ \ \ \ \ \mathbb{S}(\phi\wedge\phi^\prime\wedge \phi_g)))\}
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is satisfiable.
\end{definition}


In the post-condition of the rewrite rule we assign
the value set of input reference $r$ to the local reference $r^\prime$
and return the local reference $r^\prime$ in the next state.

Consider the graph shown in~\figref{fig:fHeap}(b) the reference
$r_2^i$ is created during the initialization of $\mathit{this}.y$. The
reference that is returned during the access of the field, however, is
$r_3^s$. The reference $r_3^s$ points to the value set of $r_2^i$
which are: $(\phi_{2a}, l_\mathit{null})$, $(\phi_{2b}, l_2)$, and
$(\phi_{2c}, l_1)$. The values of the constraints $\phi_{2a}$,
$\phi_{2b}$, and $\phi_{2c}$ are defined in~\figref{fig:initHeap}(d).

\subsection{Writing to a Field}

The reference $r_x$ is the base pointer whose field is being written
to while $r$ is the target reference. We look up the value of the base
reference in the environment $\eta(x)$. The set $\Psi_x$ is the set of
tuples of constraints, locations, and references which provide the
reference chains leading from $r_x$ to the reference of the field,
$r_\mathit{curr}$, being written to through $\phi$ and $l$.The goal is
to overwrite the $r_\mathit{curr}$ references with the target
references. Since the target of the write is $r$, we first check that the
location constraint pairs of $L(r)$ are satisfiable when accessed
through the $r_x$ chain. This is accomplished by the strengthing
function.

\begin{definition}
\label{def:ST}
The strengthen function $\mathbb{ST}(\cfgnt{L},\cfgnt{r},\phi,\phi_g)$ strengthens every
constraint from the reference $\cfgnt{r}$ with $\phi$ and keeps only location-constraint
pairs that are satisfiable after this strengthening with the inclusion of the global heap constraint $\phi_g$:
\[
\begin{array}{rcl} 
\mathbb{ST}(\cfgnt{L},\cfgnt{r},\phi,\phi_g) & = & \{ (\phi\wedge\phi^\prime\ \cfgnt{l}^\prime) \mid  \\
& & \ \ \ \ (\phi^\prime\ \cfgnt{l}^\prime)\in \cfgnt{L}(\cfgnt{r})\wedge\mathbb{S}(\phi\wedge\phi^\prime\wedge\phi_g) \}
\end{array}
\]
\end{definition}

Additionally, we also check for conditions where the write is not possible 

\begin{comment}
\begin{figure}[t]
\begin{center}
\begin{tabular}[c]{l}
$\Psi_x = \{ (true, l_0, r_1^i) \}$\\
$ST (L, r_3^s, \phi, \phi_g)$ \\
$\theta = \{ (\phi_{2a}\; l_\mathit{null} ) (\phi_{2b}\; l_2) (\phi_{2c}\; l_1) \}$\\
$ST(L, r_0, \phi, \phi_g)$\\
$\theta = \{ \}$\\
\end{tabular}
\end{center}
\caption{field write for this.x = this.y sets}
\label{fig:faHeapSets}
\end{figure}
\end{comment}

\subsection{Equality and InEquality of References}

\input{precise-eq}

\newsavebox{\boxPEX}
\savebox{\boxPEX}{
\begin{tabular}[c]{l}
$L(r_1^i) = \{ (\phi_{1a}\; l_\mathit{null})\; (\phi_{1b}\; l_1) \}$ \\
$L(r_2^i) = \{ (\phi_{2a}\; l_\mathit{null}),\; (\phi_{2b}\; l_2),\; (\phi_{2c}\; l_1) \} $\\
  $\theta_0 = \{ \} $\\
$\theta_1 = \{ \phi_{2b}\} $\\ \hline
Equals true \\
$\theta_\alpha = \{ (\phi_{1a}\; \wedge\; \phi_{2a} ) (\phi_{1b}\; \wedge\; \phi_{2c} ) \}$\\
$\phi^\prime = \mathit{true} \wedge [ (\phi_{1a}\; \wedge\; \phi_{2a} )\vee (\phi_{1b}\; \wedge\; \phi_{2c} ) ] \wedge \neg\phi_{2b} $\\ \hline
Equals false \\
$\theta_\alpha = \{ (\phi_{1a}\; \implies\; \neg\phi_{2a} ) (\phi_{1b}\; \implies\; \neg\phi_{2c} ) \}$\\
$\phi^\prime = \mathit{true} \wedge  (\phi_{1a}\; \implies\; \neg\phi_{2a} )\wedge (\phi_{1b}\; \implies\; \neg\phi_{2c} )  \wedge \phi_{2b} $\\ \hline
\end{tabular}}

\begin{figure*}
\begin{tabular}[c]{cl}
\usebox{\boxPEQ} & \usebox{\boxPEX} \\ \\
(a) & (b) \\
\end{tabular}
\caption{equals true for this.x == this.y}
\label{fig:eqs}
\end{figure*}


The rewrite rules for check the equals true and equals false when
comparing two references in the symbolic summary heap is shown
in~\figref{fig:eqs}(a). First the equals reference true rewrite rule
returns true if two references $r_0$ and $r_1$ are equal. In GSE this
is a simple comparision of object refrences. In the symbolic summary
heap, however, there we campare sets of constraint location pairs for
each reference. We construct three sets of constraints (i) In order to check whether 
there are locations, $l$ in the heap such that under some constraints $\phi_0$ references $r_0$ and $r_1$
$\Phi_\alpha$ constains combinations of constraints ($\phi_0 \wedge
\phi_1$) from $r_0$ and $r_1$
