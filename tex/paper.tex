\documentclass[conference]{IEEEtran}
\usepackage{comment}
\usepackage{mathpartir}
\usepackage{amssymb}
\usepackage{amsfonts}

\hyphenation{op-tical net-works semi-conduc-tor}

\input{cfg-commands}
\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Uber-lazy Symbolic Execution}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Suzette Person and Neha Rungta}
\IEEEauthorblockA{NASA}
\and
\IEEEauthorblockN{Eric Mercer and Benjamin Hillery}
\IEEEauthorblockA{Brigham Young University}}
\maketitle


\begin{abstract}
One of the fundamental challenges of analyzing software using
symbolic execution has been how to analyze heap manipulating
programs, i.e., programs with complex data structures with
unbounded domains. State-of-the-art symbolic execution techniques 
have addressed this challenge by constructing the heap \emph{lazily},
materializing objects on the concrete heap ``as needed'' and
using non-deterministic choice points to explore each feasible
concrete heap configuration. Because treatment of the materialized
heap locations follows concrete program semantics, scalability
of this class of programs remains challenging due to the 
state space explosion problem.
In this work we present a novel approach for lazy symbolic execution
of heap manipulating software that constructs 
a fully symbolic heap on-the-fly during symbolic execution.
Our approach is 1) \emph{scalable} -- it avoids
creating the additional points of non-determinism
introduced by current lazy initialization techniques, 
2) \emph{precise} -- at any given point during symbolic execution, 
the symbolic heap represents the exact set of feasible
concrete heap structures for the program under analysis, and
3) \emph{expressive} -- the symbolic heap can represent recursive data structures 
and heaps resulting from loops and recursive control structures in the code. 
We report on a case-study of an implementation of our technique in the
Symbolic PathFinder tool to illustrate its scalability, precision
and expressiveness, and we discuss how test case generation -- a common
 use for the results of symbolic execution -- can benefit from symbolic
 execution using a fully symbolic heap.
 
\end{abstract}
\IEEEpeerreviewmaketitle
\input{intro}
\input{motivation}
\input{pseudo-code}
\input{stateDescriptions}
\input{related}
%\input{state}
%\input{execution}
%\input{examples}
%\input{bytecode}
%\section{Conclusion}
\section*{Acknowledgment}

\bibliographystyle{IEEEtran}
\bibliography{../bib/paper}
\end{document}


