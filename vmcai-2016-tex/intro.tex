\section{Introduction}




%In recent years symbolic execution has provided the basis for various
%software testing and analysis techniques, e.g., regression
%analysis~\cite{backes:2012,Godefroid:SAS11,Person:FSE08,person:pldi2011,Ramos:2011,Yang:ISSTA12},
%data structure repair~\cite{KhurshidETAL05RepairingStructurally},
%dynamic discovery of
%invariants~\cite{CsallnerETAL08DySy,Zhang:ISSTA14}, and
%debugging~\cite{Ma:2011}.
%
%Recent work has explored the strengths and limitations of
%tools which leverage constraint solvers, e.g., concolic execution,
%identifying symbolic dereferencing and updating operations as areas
%for potential improvement~\cite{Chen:2013,Qu:2011}.  

In symbolic execution, the values of program variables are represented as constraints over the program’s inputs. During the course of an execution, a program variable may assume a number of possible values under a variety of different conditions. One way to represent this behavior is by pairing each possible value with the with the constraints under which it is assumed. A set of such value-constraint pairs, called a \emph{guarded value set}, represents the state of a program variable.

Guarded value sets are rising in importance in the representation of reference values. First appearing in Verification-Condition Generator (VCG) style techniques~\cite{Xie:2005,Dillig:2011}, guarded value sets are a convenient way to represent sets of heap shapes. More recently, guarded value sets are being used in symbolic execution for the purposes of modularization~\cite{Yorsh:2008}, state merging~\cite{Sen:2014}, and for determining invariants~\cite{Ferrara:2014,Torlak:2014}.

A common hurdle to using guarded value sets is the treatment of symbolic heap inputs. Precisely modeling operations on heap inputs is challenging because it requires formulating logical predicates over an input domain that contains a potentially unbounded number of references~\cite{Chen:2013,Qu:2011}. Manually creating test inputs can be a time consuming and error-prone process, automatic case-splitting methods~\cite{GSE03,Deng:2007} quickly produce an overwhelming number of execution paths, and user-supplied logical invariants require a high degree of skill to create. Thus, despite the advantages of using guarded value sets, it remains an open question how they can be used in symbolic execution to automatically model all possible program behaviors in the case of an arbitrary input heap.

The contribution of this work is to build on previous efforts, by demonstrating an initialization scheme that enables pointer dereferencing in an unknown symbolic input heap, and by proving that the initialization scheme is sound and complete with respect to properties provable by symbolic execution. A proof-of-concept implementation also demonstrates the efficiency of value-summary representations, as compared to existing case-splitting methods.  

