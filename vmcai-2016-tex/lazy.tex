\subsection{Generalized Symbolic Execution}
\label{app:gse}
Several projects have generalized the core idea of symbolic execution,
enabling it to be applied to programs with more general types,
including references and
arrays~\cite{GSE03,KiasanKunit,Cadar:2008,Rosner:2015}. These
generalized symbolic execution (\gsetxt{}) techniques work by branching over
multiple copies of the system state during dereferencing operations, creating
new location symbols on an as-needed basis in a process called~\emph{lazy initialization}.

The rules to generalized symbolic execution with
lazy initialization using the symbolic heap are in
\figref{fig:lazyInit} for the initialization and \figref{fig:lazy} for
how the initialization is used. Specifically, the field-access rule in
\figref{fig:lazy} uses initialization, $\rightarrow_I^*$, to ensure
the accessed field is instantiated. Initialization in generalized
symbolic execution never happens for more than one object on any use
of $\rightarrow_I^*$: $\Lambda$ is either empty or contains exactly
one location.

The~\gsetxt{} initialization rules preserve several important properties of the symbolic heap. In the heap generated by~\gsetst{}, each reference belongs to one of three partitions: $\mathrm{init}_\cfgnt{r}()$ for the \emph{input
  heap}
  ; $\mathrm{fresh}_\cfgnt{r}()$ for \emph{auxiliary
  literals}
  ; and $\mathrm{stack}_\cfgnt{r}()$ for \emph{stack
  literals}.
  Only input heap references appear in constraints to express potential aliasing.
  Auxiliary literals and stack references are used to define additional structure in the heap but only stack references can appear in environments, expressions, or continuations. Changes to $R$ are monotonically increasing, eliminating any need for constraint rewriting as the program state evolves.
A reference in $(\cfgnt{L}\ \cfgnt{R})$ cannot point to multiple locations simultaneously: 
$
\forall \cfgnt{r} \in \cfgnt{L}^\leftarrow\ (\forall (\phi\ \cfgnt{l}),(\phi^\prime\ \cfgnt{l}^\prime) \in \cfgnt{L}(r)\ (
(\cfgnt{l} \neq \cfgnt{l}^\prime \vee \phi \neq \phi^\prime) \Rightarrow (\phi \wedge \phi^\prime = \cfgt{false}))
$
where $\cfgnt{L}^\leftarrow$ is the pre-image of $\cfgnt{L}$. 
All locations associated with a reference have the same type:
$\forall \cfgnt{r} \in \cfgnt{L}^\leftarrow\ (\forall (\phi\ \cfgnt{l}),(\phi^\prime\ \cfgnt{l}^\prime) \in \cfgnt{L}(r)\ (
(\mathrm{Type}\lp\cfgnt{l}\rp = \mathrm{Type}\lp\cfgnt{l}^\prime\rp)))$

An uninitialized object may be lazily initialized
non-deterministically to null, a new instance of the object, or an to
an object of the same type also initialized lazily. The
non-deterministic initialization creates branches in the execution
tree during state space exploration. 

The $\rgse$ relation is a union over branching points on control flow
to support the final proof of the existence of a
bisimulation. Although it is apparent that there is non-determinism in
initialization, it is not the initialization where control flow
diverges in program execution. Rather, that occurs at branches and
exceptions, and that is reflected in the composition of $\rgse$.

\input{initialize-lazy}
\input{lazy-fig}
