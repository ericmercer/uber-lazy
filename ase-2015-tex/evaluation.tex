\section{Evaluation}

%\begin{figure*}[t]
\begin{table*} [t]
  \centering
  \scalebox{0.88}{\begin{tabular}{| c | c | r | r | r | r | r | r | r | r | r |}
  \hline
   \multirow{2}{*}{Method }&\multirow{2}{*}{ $k$ }
   &\multicolumn{3}{c|}{Time (seconds)} &\multicolumn{3}{c|}{States} &\multicolumn{3}{c|}{ Paths }\\
								&	&\gsetxt{} & L\#		&SL		&\gsetxt{}	& L\# & SL&\gsetxt{}	& L\# 	& SL\\
   \hline
    \multirow{3}{*}{LinkedList }			&3	& 0.91	& 1.21	& 0.69	& 2465	& 2844	& 99		&1656	& 1269	& 25\\
   		 						& 4	& 2.92	& 3.35	& 0.91	& 25774	& 29977	& 155	&17485	& 13550	& 39\\
   								& 5	& 20.78	& 19.47	& 1.59	& 341164	& 400296	& 223	&232743	& 181849	& 56\\
								& 6	& 280.56	& 299.19	& 2.36	&5447980	&6437201	& 303	&3731094	&2933027	& 76\\
								& 7	& -		& -		& 5.07	& -		&-		& 395	&-		&-		& 99\\
								& 8	& -		& -		& 17.49	& -		&-		& 499	&-		&-		& 125\\
								& 9	& -		& -		& 63.96	& -		&-		& 615	&-		&-		& 154\\
								& 10	& -		& -		& 206.93	& -		&-		& 743	&-		&-		& 186\\
    \hline
    \multirow{3}{*}{BinarySearchTree }	& 1	& 0.26	& 0.28	& 0.36	& 19		& 23		& 29		& 6		& 6		& 6\\
   		 						& 2	& 0.83	& 1.28	& 0.93	& 143	& 143	& 145	& 43		& 42		& 33\\
   								& 3	& 20.63	& 25.55	& 4.03	& 1953	& 1703	& 1485	& 515	& 515	& 328\\
								& 4	& -		& -		& 410.89	& -		&-		& 73635	&-		&-		& 15563\\
    \hline
      \multirow{3}{*}{TreeMap}			& 1	& 0.47	& 0.52	& 0.77	& 65		& 70		& 215	& 11		& 11		& 11\\
   		 						& 2	& 8.99	& 9.73	& 4.72	& 1009	& 942	& 3219	& 127	& 122	& 73\\
   								& 3	& -		& -		& 145.56	& -		& -		& 78695	& -		& -		& 887\\
						
    \hline
  \end{tabular}}
  \caption{Comparing the efficiency of the symbolic heap with the~\gsetxt{} and Lazier\# algorithms.}
  \label{tab:results}
\end{table*}

%\end{figure*}

%\subsection{Analysis}
We empirically evaluate the \symtxt{}
algorithm for analyzing programs with unbounded heap allocated
data in the context of symbolic execution.
To perform our evaluation we implemented a prototype of the \symtxt{} 
algorithm in Symbolic PathFinder (SPF)~\cite{DBLP:journals/ase/PasareanuVBGMR13} 
and evaluate its efficacy on three Java data structure artifacts.
SPF includes an implementation of~\gsetxt{} with lazy initialization.
In recent work, we implemented the  Lazier and Lazier\#
algorithms in SPF~\cite{Hillery:2014}.

The prototype of our~\symtxt{} algorithm is implemented as a new
extension to SPF.  In addition to the operations presented in the in
this paper, the implementation contains support for operations over
integers.  We are currently working on adding support for floating
point operations, arrays, and bit-operations.  We use the
\texttt{jConstraints} library which provides support for handling heap
constraints~\cite{ase2014-ghilrr,jpf2014-dghirr}. It uses the z3
solver~\cite{deMouraBjorner08Z3} as the underlying constraint
solver. We leverage the incremental solving feature in z3 in our
experiments. We also implement other optimizations that cache and
re-use solutions to previous constraints. These optimizations are an
important part of our implementation because only small portions of
the heap constraint changes from one state to another. 
The solver optimizations used in the \symtxt{} are not applicable to \gsetxt{}-style techniques, as they do not generate or solve any heap-related constraints. Even with the solver optimizations these techniques would have the same performance characteristics. The overhead in \gsetxt{} arises from case-splitting (generating states) rather than solver time. 


The benchmarks all include invariants and traversals of data structures. The chosen benchmarks have a high proportion of heap-related operations, putting maximum focus on the heap analysis methods under investigation. They are included to provide evidence of the general computational efficiency of the SH approach. In future work we plan to evaluate it on a more diverse set of benchmarks. The BinarySearchTree test uses the class of the same name from Alan Weiss' book titled ``Data Structures and Algorithm Analysis in Java''. The test method first asserts a repOk() invariant, before conducting a traversal to find an arbitrary integer key in the tree. The TreeMap method comes from the standard java.util library, and is an implementation of a balanced red/black tree. This method asserts a repOk() invariant, before traversing the tree. The LinkedList test starts by asserting a repOk() invariant, which checks for loops in the linked list using Floyd’s cycle-finding algorithm. The linked list is then traversed using a contains() method that attempts to locate an arbitrary reference key in the list.

All benchmarks were performed with respect to a given k-bounds. k-bounding limits the length of reference chains to some user-defined integer k. k-bounding was chosen because it provides a fair means of comparison of all the techniques under investigation. More details on k-bounding can be found in~\cite{Deng:2007}.

The results of the experiments are presented in Table~\ref{tab:results}. 
Each row reports the results for the specified $k$-bound 
for each artifact evaluated. The columns show the total
wall clock time in seconds, states explored, and paths generated for
each algorithm. The headings \gsetxt{}, L\#, and SH correspond
to the Generalized Symbolic Execution, Lazier\#, and \symtxt{}
algorithms, respectively. Note that we omit the results for
the Lazier algorithm because they are nearly identical to the Lazier\#
results for these artifacts. A table entry of  '-' indicates the analysis
exceeded the allotted time bound of 10 minutes.

The results in Table~\ref{tab:results} demonstrate the efficiency of the 
\symtxt{} algorithm, especially for
large $k$-values. Performance improvement ranges from $4.8x$ for
BinarySearchTree at $k$=3, to $118x$ for LinkedList at $k$=6. In fact,
for some $k$-bounds a number of experiments completed exploration
using the \symtxt{} algorithm in a few seconds whereas \gsetxt{} or Lazier\# were
unable to finish, e.g., BinarySearchTree for $k$=4 and LinkedList for
$k$=8. These results demonstrate the potential of using the \symtxt{} algorithm 
to analyze programs with complex types. The lower running times
show that we can prove properties using the \symtxt{} algorithm 
faster than \gsetxt{}.

The number of states explored varies between algorithms. For example,
\gsetxt{} creates additional points of nondeterminism during field reads, 
while reference compares are completely deterministic. Thus, in
example programs with large numbers of reference compares, e.g.,
TreeMap, state counts for Lazier\# and the \symtxt{} algorithm may
exceed those for \gsetxt{}. We observed that the additional states
generated by the symbolic heap algorithm are unsatisfiable at the point
of reference compares; this is why they do not contribute any
additional branches in the final symbolic execution tree. Furthermore,
the larger state count does not impact the overall runtime of the
technique.

% Some of this discrepancy may be accounted for by the fact that
%\symtxt{} is equipped for incremental solving, however, during
%informal testing with the incremental solver turned off, \symtxt{}
%usually performed better than \gsetxt{} and Lazier\#, especially in
%test runs with high k-bounds.

The path counts shown in Table~\ref{tab:results} also show the advantage
of the \symtxt{} algorithm over the \gsetxt{} and L\# algorithms, each of
which performs case-splitting during the analysis.
The number of paths explored by the \symtxt{} algorithm is strictly 
less than or equal to the number
of paths explored by \gsetxt{} for all artifacts. As a result,
fewer test cases will be generated to achieve the same control-flow 
path coverage when compared to~\gsetxt{} and Lazier\#.

%In summary, the benefits of avoiding
%initialization-based non-determinism outweigh the increased
%complexity in the constraints due to the advances made in SMT
%solvers in these examples. In fact, the \symtxt{} algorithm can analyze certain types of programs with
%orders of magnitude greater efficiency than with \gsetxt{} or
%Lazier\#, while covering exactly the same control flow paths. 

%We can use this
%result to do more efficient test case generation. From a path
%generated we can use the solutions provided by the constraint solver
%to instantiate a set of concrete heaps to provide as test input. 


%Interestingly, \symtxt{} path growth appears
%to be sub-exponential in $k$ for the LinkedList program.




%The additional states generated by summary heap are unsatisfiable
%which is why they do not add nodes in the final symbolic execution
%tree. Furthermore, the larger state count does not impact the overall
%runtime of the technique.

% Despite this, in practice this is often mitigated by the
%fact that \symtxt{} can dispatch address compares without consulting
%the constraint solver.


