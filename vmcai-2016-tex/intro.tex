\section{Introduction}

In recent years symbolic execution has provided the basis for various
software testing and analysis techniques, e.g., regression
analysis~\cite{backes:2012,Godefroid:SAS11,Person:FSE08,person:pldi2011,Ramos:2011,Yang:ISSTA12},
data structure repair~\cite{KhurshidETAL05RepairingStructurally},
dynamic discovery of
invariants~\cite{CsallnerETAL08DySy,Zhang:ISSTA14}, and
debugging~\cite{Ma:2011}.

Recent work has explored the strengths and limitations of
tools which leverage constraint solvers, e.g., concolic execution,
identifying symbolic dereferencing and updating operations as areas
for potential improvement~\cite{Chen:2013,Qu:2011}.  Precisely
modeling these operations, however, is challenging because it requires
formulating logical predicates over an input domain that contains a
potentially unbounded number of references.

A promising approach to this problem has been to
to partition the reachable heaps by using \emph{symbolic heap}
representations, where multiple values for a reference may be
represented along a single execution
path~\cite{Dillig:2011,Elkarablieh:2009,Sen:2014,Torlak:2014,Xie:2005,Yorsh:2008}. However, it remains an open question whether or not these methods can be used to exactly model all possible program behaviors in the case of an arbitrary input.

The contribution of this work is to build on these previous efforts, by demonstrating how to dereference pointers in an unknown symbolic input heap, thereby proving that value-summary representations are sound and complete with respect to properties provable by symbolic execution. A proof-of-concept implementation also demonstrates the efficiency of value-summary representations, as compared to the previous best-known exact analysis method.  

\begin{comment}
\section{Introduction}

% SymExe is cool because for reasons x,y, and z

In recent years symbolic execution has provided the basis for various
software testing and analysis techniques. Symbolic execution
systematically explores the program execution space representing input
values symbolically, and for each explored path, it computes
constraints on the symbolic inputs to create a \emph{ path condition}.
Path conditions computed by symbolic execution characterize the
observed program execution behaviors and have been used as an enabling
technology for various applications, e.g., regression
analysis~\cite{backes:2012,Godefroid:SAS11,Person:FSE08,person:pldi2011,Ramos:2011,Yang:ISSTA12},
data structure repair~\cite{KhurshidETAL05RepairingStructurally},
dynamic discovery of
invariants~\cite{CsallnerETAL08DySy,Zhang:ISSTA14}, and
debugging~\cite{Ma:2011}.


The path conditions computed by symbolic execution have two important
characteristics: 1) they characterize the set of feasible execution
paths, i.e., infeasible paths are omitted, and 2) each path condition
represents the set of concrete program inputs that would cause
execution to follow that program path. Because path conditions are
encoded as constraints over program inputs, the reasoning capabilities
of symbolic execution are limited by the underlying constraint solver.
Thus, extending the capabilities of symbolic execution to reason about
new theories is an area of active research. Of particular interest are
symbolic dereferencing and updating
operations~\cite{Chen:2013,Qu:2011}. Precisely modeling these
operations is challenging, because it requires formulating logical
predicates over an input domain containing a potentially unbounded
number of references.

Current strategies for symbolic dereferencing require making tradeoffs
between the completeness of the analysis and the completeness of the
path condition. For example, one simple approach is to terminate
execution upon attempting to dereference any symbolic
value~\cite{Clarke:2004}. While this preserves the integrity of the
path condition, it comes at the cost of an incomplete analysis. To
enable a more complete analysis, dynamic symbolic execution (\dsetxt{}),
approximates the results of a symbolic dereferencing by substituting
in a valid concrete
value~\cite{Godefroid:POPL07,Godefroid:2005,Sen:2005,Tillmann:2008}. This
allows execution to continue, but the approximation renders the path
condition incomplete~\cite{Chen:2013,Elkarablieh:2009}, by effectively
partitioning the space of input heaps into those where the result of
the dereferencing matches the concrete execution. Larger partitions
can be achieved by using value summary representations, where multiple
values for a reference may be represented along a single execution
path~\cite{Dillig:2011,Elkarablieh:2009,Sen:2014,Torlak:2014,Xie:2005,Yorsh:2008}. Systems
using these representations perform analyses that are more complete
than standard~\dsetxt{} methods, but their associated dereferencing
operations require placing further restrictions on the input heap,
such as limiting the number of nodes~\cite{Elkarablieh:2009}, the
nature of aliasing relationships~\cite{Babic:2007,Xie:2005}, or the
shape of the heap itself~\cite{Dillig:2011}. Finally, at the opposite
end of the spectrum lies generalized symbolic execution
(\gsetxt{})~\cite{Cadar:2008,KiasanKunit,GSE03,Rosner:2015}, which
accomplishes a fully complete analysis at the cost of an incomplete
path condition \sjp{not clear what an incomplete path condition
  is}. On symbolic dereferencing operations,~\gsetxt{} partitions the input
space between the various possible aliasing configurations
\sjp{so?}. Thus, none of the current techniques provide the option of
maintaining both a complete analysis and a complete path
condition. This is in stark contrast to symbolic execution over
primitive types, which enjoys both properties simultaneously.

\sjp{Need to explain that the techniques still operate within some bound for loops, etc.}

\sjp{Notion of on-the-fly updates is not here}

\sjp{Nowhere do we refer to the technique as a summary heap framework or algorithm,
so the next section with its heading just jumps out of nowhere.}

This paper introduces a technique that avoids these problems by
preserving the following properties of classical symbolic execution:
(i) Inputs are represented by unbounded and unconstrained input
symbols. This lack of predetermined constraints is key to avoiding
under-approximation, which in turn is required for performing a
complete analysis. (ii) Points of nondeterminism are only introduced
at control flow instructions, which is critical for maintaining a
complete path condition for a given control flow path.

\noindent{This paper makes the following contributions:}

\begin{compactdesc}

\item\textbf{-} A system for reasoning symbolically about the 
set of input heaps along any valid program path that is sound
and complete with respect to symbolic execution. 

\item\textbf{-} A bisimulation proof establishing the soundness and 
completeness of the heap summary approach with respect to
properties provable by~\gsetxt{}.

\item\textbf{-} A proof-of-concept implementation and empirical study 
demonstrating the scalability of the summary heap approach
compared to other~\gsetxt{} approaches.

\end{compactdesc}
\end{comment}
