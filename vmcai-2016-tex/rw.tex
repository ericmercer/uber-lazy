\section{Related Work}
\label{sec:related}
%
%\subsection{Program Analysis using Symbolic Heaps}
The symbolic heap methods in this work build upon a
number of prior program analysis techniques that use guarded value sets to
represent program
state~\cite{Sen:2014,Torlak:2014,Yorsh:2008,Xie:2005,Dillig:2011,Elkarablieh:2009}. In particular, the field write and equals reference compare are not much different than what is already in these works. The real contribution of \symtxt\ is the initialization part of the field access rules which preserves the \gsetxt\ semantics.
The method was pioneered in Verification-Condition Generator (VCG) style techniques such as ~\cite{Xie:2005,Yorsh:2008}, where value sets were used to 
represent aliasing-free tree-like heaps. The work in~\cite{Dillig:2011} relaxed the aliasing restrictions by using a pre-computed set of symbolic input heaps.

Recently, value sets have been adapted for use in symbolic execution, for the purposes of state merging ~\cite{Sen:2014,Torlak:2014} and invariant detection~\cite{Ferrara:2014}. While these methods demonstrate the utility of value sets in combination with symbolic execution, none of these techniques address dereferencing of symbolic input references. Since dereferencing is a fundamental problem treated in this paper, these other works may be considered both orthogonal and complimentary to~\symtxt{}.

%\subsection{Other Heap Representations in Symbolic Execution}
%Need to talk about GSE, DSE, SAGE, PEX
%GSE
Several projects have generalized the core idea of symbolic execution,
enabling it to be applied to programs with more general types,
including references and
arrays~\cite{GSE03,KiasanKunit,Cadar:2008,Rosner:2015}. However, these
generalized symbolic execution (\gsetxt{}) techniques work by branching over
multiple copies of the system state during dereferencing operations,
exacerbating path explosion.

%DSE
Dynamic symbolic execution (\dsetxt{}) techniques may use
concretization when reasoning about references~\cite{Godefroid:2005,Sen:2005,Godefroid:POPL07,Tillmann:2008}, enabling much greater program
coverage than classical symbolic execution alone. In particular, PEX~\cite{Tillmann:2008}
has demonstrated a high degree of utility in a wide variety of 
practical verification scenarios. Sometimes,
however, as demonstrated in~\cite{Elkarablieh:2009},~\dsetxt{}
under-approximates the possible heaps configurations when it
concretizes symbolic values. The SAGE~\dsetxt{}
engine~\cite{Elkarablieh:2009} includes more sophisticated methods for
reasoning symbolically about references, and can successfully handle
complicated examples. However, SAGE uses a
theory of fixed-length arrays to model the heap, and is thus incomplete
for programs with input-dependent memory allocation. It is hoped that the 
techniques presented in this work can be used to extend practical tools 
like PEX for applications requiring formal correctness guarantees.

%
%\subsection{Formal Results on Symbolic Heaps}
The symbolic heap used by SAGE~\cite{Elkarablieh:2009} was shown to be sound and complete for programs with input-independent memory allocation.~\symtxt{} is sound and complete for all states reached by symbolic execution. 

Recently, several separation logic solvers have been proven to be sound and complete for heaps with linked lists, trees~\cite{Piskac:2014}, or data structures satisfying user-supplied invariants~\cite{Brotherston:2014}. In contrast,~\symtxt{} is sound and complete without restriction on data structures, and requires no explicit invariants, but this result is restricted to the properties provable by symbolic execution. 

The heap in~\cite{Dillig:2011} was proven to be monotonic with respect to the number of valid solutions. 

Some heap methods, such as those used by VC generators, may be sound and complete if the correct bounds are chosen. However, choosing the bounds is at least as hard as analyzing the program. 





%Odds and ends leftover from last time:

%Our work leverages the core idea in generalized symbolic execution
%with lazy initialization using on-the-fly reasoning to model a
%black-box input heap during symbolic execution, but avoids the
%nondeterminism introduced by~\gsetxt{} by constructing a single
%symbolic heap and polynomially-sized path condition for each control
%flow path.
%
%Recent progress has been made towards mitigating path explosion via state merging~\cite{Kuznetsov:2012,Sen:2014,Torlak:2014}. 
%
%

%
%Many bounded model checking (BMC) methods include a model for
%reasoning about references, including those described
%in~\cite{Clarke:2004,Barnett:2006,Xie:2005,Babic:2007,Dillig:2011}. However,
%BMC techniques generally need to predetermine bounds of a heap. Other
%limitations include assuming that symbolic references do not
%alias~\cite{Xie:2005,Babic:2007}, that data structures are not
%recursive~\cite{Dillig:2011}, or prohibiting dereferencing of
%black-box input references~\cite{Clarke:2004}.
%
%A number of constraint-based programming techniques are capable of
%reasoning about
%heaps~\cite{Degrave:2010,Charreteur:2009,Albert:2013}. Most notably,
%the technique in~\cite{Albert:2013} is capable of reasoning about
%dereferencing operations in a per-path set of unknown input
%heaps. However, no guarantees are made about the precision of the
%analysis performed.
%
%
%
