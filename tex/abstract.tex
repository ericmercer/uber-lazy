
A fundamental challenge of using symbolic execution for software
analysis is the treatment of dynamically allocated data. This paper
introduces a compact symbolic heap representation based on a field
sensitive points-to graph with edges annotated with disjunctive
formulas describing aliasing relationships, along with a set of
rewrite rules that describe the initialization, dereferencing, and
update to fields in the symbolic heaps. The symbolic heap supports
arbitrary recursive data structures and captures all possible heaps
that follow a common control flow path up to the point of
execution. An evaluation of a proof-of-concept implementation in the
Java Pathfinder framework is presented to demonstrate the
computational feasibility of the approach over several classical
symbolic execution benchmarks.


%A fundamental challenge of using symbolic execution for software
%analysis is the treatment of dynamically allocated data. Existing
%static analysis techniques over-approximate the potential heaps,
%dynamic symbolic execution techniques often under-approximate the
%heaps, while generalized symbolic execution leads to excessive
%case-splitting. This paper introduces a compact heap representation,
%along with heap update rules that (i) allow reads and writes of
%symbolic references, (ii) do not require constraint rewriting, and
%(iii) support arbitrary recursive data structures. As such, the
%representation and update rules capture all possible heaps that
%follow a common execution path. More importantly, in contrast to
%existing state-of-the-art techniques, the definition and update rules
%are unconstrained and not subject to bounds, such as the number of
%heap locations, aliasing, or memory partitions. An evaluation of a
%proof-of-concept implementation in the Java Pathfinder framework is
%presented to demonstrate the computational feasibility of the
%approach over several classical symbolic execution benchmarks.
