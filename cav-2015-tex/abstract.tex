A fundamental challenge of using symbolic execution for software
analysis is the treatment of dynamically allocated data. Existing
static analysis techniques over-approximate the potential heaps,
dynamic symbolic execution techniques often under-approximate the
heaps, while generalized symbolic execution leads to excessive
case-splitting. This paper introduces a compact heap representation
along with heap update rules that (i) allow reads and writes of
symbolic references, (ii) does not require constraint rewriting, and
(iii) supports arbitrary recursive data structures. As such, the
representation and update rules capture all possible heaps that follow
a common execution path. More importantly, in contrast to
state-of-the-art techniques, the definition and update rules are
unconstrained and not subject to bounds such as the number of heap
locations, aliasing, or memory partitions. An evaluation of a
proof-of-concept implementation in the Java Pathfinder framework is
presented to demonstrate the computational feasibility of the approach
over several classical symbolic execution benchmarks.
