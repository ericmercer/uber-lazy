%\begin{figure*}[t]
\begin{table*} [t]
  \centering
  \scalebox{0.88}{\begin{tabular}{| c | c | r | r | r | r | r | r | r | r | r |}
  \hline
   \multirow{2}{*}{Method }&\multirow{2}{*}{ $k$ }
   &\multicolumn{3}{|c|}{Time (seconds)} &\multicolumn{3}{|c|}{States} &\multicolumn{3}{|c|}{ Paths }\\
								&	&\gsetxt{} & L\#		&SL		&\gsetxt{}	& L\# & SL&\gsetxt{}	& L\# 	& SL\\
   \hline
    \multirow{3}{*}{LinkedList }			&3	& 0.91	& 1.21	& 0.69	& 2465	& 2844	& 99		&1656	& 1269	& 25\\
   		 						& 4	& 2.92	& 3.35	& 0.91	& 25774	& 29977	& 155	&17485	& 13550	& 39\\
   								& 5	& 20.78	& 19.47	& 1.59	& 341164	& 400296	& 223	&232743	& 181849	& 56\\
								& 6	& 280.56	& 299.19	& 2.36	&5447980	&6437201	& 303	&3731094	&2933027	& 76\\
    \hline
    \multirow{3}{*}{BinarySearchTree }	& 1	& 0.26	& 0.28	& 0.36	& 19		& 23		& 29		& 6		& 6		& 6\\
   		 						& 2	& 0.83	& 1.28	& 0.93	& 143	& 143	& 145	& 43		& 42		& 33\\
   								& 3	& 20.63	& 25.55	& 4.03	& 1953	& 1703	& 1485	& 515	& 515	& 328\\
    \hline
      \multirow{3}{*}{TreeMap}			& 1	& 0.47	& 0.52	& 0.77	& 65		& 70		& 215	& 11		& 11		& 11\\
   		 						& 2	& 8.99	& 9.73	& 4.72	& 1009	& 942	& 3219	& 127	& 122	& 73\\
   								& 3	& -		& -		& 145.56	& -		& -		& 78695	& -		& -		& 887\\
						
    \hline
  \end{tabular}}
  \caption{Comparing the efficiency of the summary heap approach to GSE and Lazier\# algorithms.}
  \label{tab:results}
\end{table*}
%\end{figure*}

%\subsection{Analysis}

The results of the experiments are presented in Table
\ref{tab:results}. Each row contains the results for the specified $k$-bound 
for each artifact evaluated. The columns show the total
wall clock time in seconds, states explored, and paths generated for
each of the algorithms. The headings \gsetxt{}, L\#, and SL correspond
to the Generalized Symbolic Execution, lazier\#, and \symtxt{}
algorithms, respectively. Note that we do no present the results for
the lazier algorithm since they are almost identical to that of lazier\#
for our examples. Table entries containing '-' correspond to test runs
that exceeded the allotted time bound of 10 minutes.

In most tests, run times strongly favor the \symtxt{} algorithm, especially for
large $k$-values. Performance improvement ranges from $4.8x$ for
BinarySearchTree at $k$=3, to $118x$ for LinkedList at $k$=6. In fact,
for certain $k$-bounds a number of experiments completed exploration
using the \symtxt{} algorithm in a few seconds whereas \gsetxt{} or lazier\# were
unable to finish, e.g., BinarySearchTree for $k$=4 and LinkedList for
$k$=8. These results demonstrate the potential of using the \symtxt{} algorithm 
to handle data input for complex types. The lower running times
show that we can prove properties using the \symtxt{} algorithm faster than
\gsetxt{}.

% Some of this discrepancy may be accounted for by the fact that
%\symtxt{} is equipped for incremental solving, however, during
%informal testing with the incremental solver turned off, \symtxt{}
%usually performed better than \gsetxt{} and lazier\#, especially in
%test runs with high k-bounds.

Path counts likewise substantially favor the \symtxt{} algorithm. The number of
paths explored by the algorithm is strictly less than or equal to the number
of paths explored by \gsetxt{} for all test cases. We can use this
result to do more efficient test case generation. From a path
generated we can use the solutions provided by the constraint solver
to instantiate a set of concrete heaps to provide as test input. These
can provide a smaller test suite to achieve control-flow path coverage when
compared to GSE and Lazier\#.


%Interestingly, \symtxt{} path growth appears
%to be sub-exponential in $k$ for the LinkedList program.

The number of states varies between algorithms, for example, \gsetxt{}
has additional points of nondeterminism during field reads, but in
contrast reference compares are completely deterministic. Thus, in
example programs with large numbers of reference compares, such as
TreeMap, state counts for lazier\# and the \symtxt{} algorithm may
exceed those for \gsetxt{}. We observed that the additional states
generated by the summary heap algorithm are unsatisfiable at the point
of reference compares; this is why they do not contribute any
additional branches in the final symbolic execution tree. Furthermore,
the larger state count does not impact the overall runtime of the
technique.


%The additional states generated by summary heap are unsatisfiable
%which is why they do not add nodes in the final symbolic execution
%tree. Furthermore, the larger state count does not impact the overall
%runtime of the technique.

% Despite this, in practice this is often mitigated by the
%fact that \symtxt{} can dispatch address compares without consulting
%the constraint solver.

In summary, the benefits of avoiding
initialization-based non-determinism outweigh the increased
complexity in the constraints due to the advances made in SMT
solvers in these examples. In fact, the \symtxt{} algorithm can analyze certain types of programs with
orders of magnitude greater efficiency than with \gsetxt{} or
lazier\#, while covering exactly the same control flow paths. 
