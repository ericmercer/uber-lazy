\section{Introduction}

In recent years symbolic execution has provided the basis for various
software testing and analysis techniques. Symbolic execution
systematically explores the program execution space using symbolic
input values, and for each explored path, computes constraints on the
symbolic inputs to create a \emph{ path condition}.  The path
conditions computed by symbolic execution characterize the observed
program execution behaviours and have been used as an enabling
technology for various applications, e.g., regression
analysis~\cite{backes:2012,Godefroid:SAS11,Person:FSE08,person:pldi2011,Ramos:2011,Yang:ISSTA12},
data structure repair~\cite{KhurshidETAL05RepairingStructurally},
dynamic discovery of
invariants~\cite{CsallnerETAL08DySy,Zhang:ISSTA14}, and
debugging~\cite{Ma:2011}.

Initial work on symbolic execution largely focused on checking
properties of programs with primitive
types~\cite{clarke76TSE,King:76}.  With the advent of object-oriented
languages, recent work has generalized the core ideas of symbolic
execution to enable analysis of programs containing complex data
structures with unbounded domains, i.e., data stored on the
heap~\cite{Kiasan06,Kiasan07,GSE03}.  These \emph{Generalized Symbolic
  Execution} (GSE) techniques construct the heap in a lazy manner,
deferring materialization of objects on the concrete heap until they
are needed for the analysis to proceed. The materilization creates
additional non-deterministic choice points in the symbolic execution
tree by representing the feasible heap configurations as (i) null,
(ii) an instance of a new reference of a compatible class, and (iii)
an alias to a previously initialized symbolic reference.  Symbolic
execution then follows concrete program semantics for materialized
heap locations. Although this approach enables the analysis of heap
manipulating programs, a large number of feasible concrete heap
configurations are created leading to a path explosion.


The goal of this work is to mitigate the path explosion problem in GSE
by grouping multiple heaps together and only partitioning the heaps at
points of divergence in the control flow graph. Our inspiration is
found in the domain of static analysis that uses sets of constraints
over heap locations to encode multiple heaps in a single
representation. These sets, sometimes known as \emph{value sets} or
\emph{value summaries}, allow multiple heaps to be represented
simultaneously with a higher degree of precision than afforded by
traditional techniques for shape analysis. Some of these previous
attempts, however, are unable to handle aliasing in heaps due to a
recursive definition of objects~\cite{Xie:2005}, while others require
a set of heaps as input and are unable to initialize heaps
on-the-fly~\cite{Dillig:2011,Tillmann:2008}.  As is typical in static
analysis, over approximation of the heap representations alleviates
some of these limitations but often leads to infeasible heaps. Also,
most static analysis techniques for heap updates require a rewrite of
the constraint system making it prohibitive for use in the context of
symbolic execution.

In this work, to effectively represent multiple heaps simultaneously
in the context of symbolic execution, we define a novel heap
representation and an algorithm to initialize and update the heap
on-the-fly. In essence, our summary heap approach supports aliasing,
does not require constraint rewriting on heap updates, and reduces
non-determinism in the search space during symbolic execution.

We represent the heap as a bipartite graph consisting of references
and locations. Each reference is able to point to multiple locations,
where each edge is predicated on constraints over aliasing between
references. Each location points to a single reference for a given
field. The use of a bipartite graph affords two key advantages: (i) it
allows for a non-recursive definition of objects which enables us to
support aliasing, and (ii) it does not introduce auxiliary variables
or require rewriting of non-local constraints during updates to the
heap.

The summary heap algorithm defines how the bipartite graph is updated
during lazy initialization. Unlike GSE, however, the summary heap
algorithm introduces non-determinism in the search only at points of
divergence in the control flow graph. These points of non-determinism
are at field accesses that lead to null-pointer exceptions and at
comparisons of references. The former represents a divergence due to
exceptional control flow while the latter is due to program structure.
The combination of the heap representation and the summary heap
algorithm enables us to improve the efficiency of symbolic execution
of heap manipulating programs over state-of-the-art techniques.

% The precise heap representation based on a bipartiate graph coupled
%with this algorithm to perform updates to the heap enable us to
%successfully mitigate the state space explosion problem in GSE.



\begin{comment}
In
practical terms, any property that can be proved using GSE can also be
proved using summary heaps, and, any property proved by
summary heaps can also be proved by GSE. Of course, both require a
bound on heap reference chains and loops.
\end{comment}

%Aside from the novelty of the heap summary and its application to
%symbolic execution, the new data structure appears to ameliorate
%state explosion in symbolic execution as hoped.

The summary heap algorithm is sound and complete with respect to
properties that are provable using GSE. This proof is accomplished by
showing the existence of a bisimulation between states in GSE and
states in the summary heap algorithm.  A preliminary implementation in
Java Pathfinder (JPF) shows that in general, the heap summary
algorithm improves over other state-of-the-art techniques, and in some
instances, the improvement is remarkable: two-orders of magnitude
reduction in running time. More importantly though, the heap summary
enables the initialization of larger more complex heaps than
previously possible as shown in our results.


%, described in this paper, compares the heap summary algorithm on a
%handful of benchmarks, each representing different degrees of
%initialization and branching, to GSE with lazy initialization in
%Symbolic Pathfinder (SPF) and implementation lazier\# also in
%SPF. The results

\begin{comment}
We implement the summary heap algorithm as an extension to \emph{Java
  PathFinder} (JPF) and compare it to GSE with lazy initialization in
\emph{Symbolic Pathfinder (SPF)} and an implementation of lazier\#
initialization in SPF.  The comparison shows on some examples up to a two-order of magnitude
reduction in the total time taken to explore the same state space
defined by the bound on the longest heap reference chain.  For these
examples, we show that where other GSE approaches are unable to
complete exploration within the provided time bound, the summary heap
finishes exploration in a few seconds.
\end{comment}

%shows that it can improve the scalability of symbolic execution of
%heap manipulating programs X fold over GSE-based analyses while
%maintaining precision and efficiency.

%preserves the heap
%configurations and program behaviors 

%complete --> anything prove with GSE you can with heap sound -->
%preserves the same behaviors in the GSE machine.

%Our analysis improves on existing GSE approaches by reducing
%the size of the symbolic execution state space explored, thereby
%improving scalability of symboic execution for heap manipulating
%software. It improves on existing heap summarization techniques by
%enabling analysis of arbitrary recursive data structures (no initial
%heap configuration is required) while avoiding the imprecision
%introduced by these techniques.

%\nsr{a paragraph that provides a breif summary of the results.. would
%  be nice if we have numbers for lazier and lazier Sharp as well.}


\noindent{This paper makes the following contributions:}

\begin{compactdesc}

%\item\textbf{-} A summary heap that represents sets of concrete heaps
% without approximation or morphological restrictions.

\item\textbf{-} A non-approximate, morphologically arbitrary, and efficient 
summary heap representation.

\item\textbf{-} An algorithm to dynamically initialize, summarize, and
  update the summary heap during symbolic execution.

\item\textbf{-} A bisimulation proof establishing the soundness and 
completeness of the heap summary approach with respect to
properties provable by GSE.

\item\textbf{-} A proof-of-concept implementation and empirical study 
demonstrating the scalability of the summary heap approach
compared to other GSE approaches.

\end{compactdesc}


%\begin{compactdesc}
%
%\item\textbf{-} A summary heap as a bipartite graph that supports
%  aliasing and does not require rewriting of constraints.
%
%% to handle alias and efficient updates of constraints.
%
%\item\textbf{-} A summary heap algorithm to initialize, summarize, and
%  update the bipartiate graphs during symbolic execution.
%
%\item\textbf{-} A proof of the existence of a bisimulation relation to establish
%  that the heap summary approach is sound and complete with respect to
%  properties provable by GSE.
%
%\item\textbf{-} A proof of concept implementation and small empirical study to demonstrate the scability of the heap summary approach
%  compared to other GSE approaches.
%
%\end{compactdesc}


%The rest of this paper defines summary heap and its to symbolic
%execution. Following the algorithm definition, the existence proof of
%bisimulation is given with the accompanying corollaries for soundness
%and completeness. This is followed by the implementation in JPF and
%the evaluation. The paper ends with the conclusion and future work.


%\item{We present a novel inter-procedural analysis technique for 
%symbolic execution of heap manipulating software which constructs 
%a precise heap summary.}
%\item{We use the JavaLite language~\cite{saints-MS} to formalize 
%the algorithm for constructing and manipulating the heap summary
%on-the-fly during symbolic execution.}
%\item{We implement our approach in the Symbolic PathFinder tool and
%empirically demonstrate that our technique improves
%the scalability of symbolic execution of heap maninpulating software
%over GSE, while maintaining efficiency and precision.}
%\item{We prove that at any given point during symbolic execution, the symbolic 
%heap represents the exact set of feasible concrete heap structures 
%for the program under analysis.}
% \end{description}

%\nsr{needs
%  some text on the fact we use java lite to formalize the heap
%  summary, some key characteristicss of the heap such as the fact it
%  is a bipartiate graph with locations and referneces, properties of
%  the heap such as the determinism and immutability}

%\nsr{Is any part of the formalism borrowed
%from the dilligs? Which part are unique?}  \nsr{end on a couple
%sentences about the various rules that will be talked about in the
%paper}

%\nsr{The reader should be convinced about our expressiveness
%  claim here}

%\nsr{a paragraph that provides intution on how we are a bisumulation
%  with the GSE..reader should be convinced about the precision claim}

\begin{comment}
\newcommand{\Indstate}[1][1]{\State\hspace{#1\algorithmicindent}}

\begin{figure}
\begin{center}
\begin{algorithmic}[1]
\Procedure{load}{$r,f$}
\If{$r$ is initialized and $f$ is uninitialized}
\If{ $f$ has a reference type}
\State nondeterministically assign to $f$:
\State  \ \ null  %hacky way to indent.
\State \ \ non-null
\EndIf
\If{$f$ has a primitive type}
\State assign $f$ a new symbol
\EndIf
\EndIf
\If{$r$ is uninitialized}
\State nondeterministically assign to $f$:
\State  \ \ a new symbolic location  %hacky way to indent.
\State \ \ an existing symbolic location
\EndIf
\State\Return $r.f$
\EndProcedure
\end{algorithmic}
\end{center}
\caption{Lazier\# Initialization}
\end{figure}

Lazy initialization is a symbolic execution technique where memory structures are created on-demand, as they are required.
\end{comment}



