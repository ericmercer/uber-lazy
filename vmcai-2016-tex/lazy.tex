\section{GSE}
\label{app:gse}
Classical GSE and its variants all subscribe to the same ideal: an uninitialized object may be lazily initialized
in a non-deterministic way to null, a new instance of the object, or an to
an object of the same type also initialized lazily (i.e., the \emph{input heap}) \cite{GSE03,KiasanKunit,Cadar:2008,Rosner:2015}. The
non-determinism creates branches in the execution
tree during state space exploration. GSE semantics are defined here to give insight to symbolic initialization and support the proof that it preserves GSE behaviors. 

The rules for classical GSE using the symbolic heap are in
\figref{fig:lazyInit} for lazy initialization: NULL, new, and alias. Fresh references and locations strictly increase so it is possible to minimize over a set to find the first created. References are partitioned to support latter proofs: $\mathrm{init}_\cfgnt{r}()$ for the input
  heap
  ; $\mathrm{fresh}_\cfgnt{r}()$ for \emph{auxiliary
  literals}
  ; and $\mathrm{stack}_\cfgnt{r}()$ for \emph{stack
    literals}.
  In general, as shown in the next section,
  only input heap references appear in constraints to express potential aliasing, and only stack references can appear in environments, expressions, or continuations.  Finally, the \emph{isInit} is true for initialized references from the input heap (i.e., potential aliases). 

How the lazy
initialization is used is defined in \figref{fig:lazy}. Specifically,
the field-access rule in \figref{fig:lazy} uses initialization,
$\rightarrow_I^*$, to ensure the accessed field is
instantiated. Initialization in generalized symbolic execution never
happens for more than one object on any use of $\rightarrow_I^*$:
$\Lambda$ is either empty or contains exactly one location. The rest of the rules in \figref{fig:lazy} do not initialize, but they are included to elucidate how symbolic initialization differs from GSE with lazy initialization. 


The $\rgse$ relation defined in \figref{fig:lazy} is a union over branching points on control flow
to support the final proof of the existence of a
bisimulation. Although it is apparent that there is non-determinism in
initialization, it is not the initialization where control flow
diverges in program execution. Rather, that occurs at branches and NULL-exceptions, and that is reflected in the composition of $\rgse$.

\input{initialize-lazy}
\input{lazy-fig}
