\begin{figure*}[t]
\begin{center}
\mprset{flushleft}
\begin{mathpar}
	\inferrule[NULL]{}{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgt{null}\ \cfgnt{k}\rp \rightarrow \\\\ 
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}_\mathit{null}\ \cfgnt{k}\rp 
	}
\and
	\inferrule[Variable lookup]{}{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{x}\ \cfgnt{k}\rp  \rightarrow \\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \eta\lp \cfgnt{x}\rp \ \cfgnt{k}\rp 
	}
\and
	\inferrule[New]{
      \mathrm{fresh}_r\lp \rp  = \cfgnt{r} \\
      \mathrm{fresh}_l\lp \cfgnt{C}\rp  = l \\\\
      \cfgnt{R}[\forall \cfgnt{f} \in \mathit{fields}\lp \mathrm{C}\rp \ \lp \lp l\ \cfgnt{f}\rp  \mapsto \mathrm{fresh}_r\lp \rp \rp ] = \cfgnt{R}^\prime \\\\
      \{r^\prime \mid \exists \cfgnt{f} \in \mathit{fields}\lp \mathrm{C}\rp \ \lp \cfgnt{r}^\prime = \cfgnt{R}^\prime\lp l, \cfgnt{f}\rp \rp \} = \rho \\\\
      \cfgnt{L}[\cfgnt{r} \mapsto \{\lp \phi_T\ l\rp \}][\forall \cfgnt{r}^\prime \in \rho\ \lp \cfgnt{r}^\prime \mapsto \lp \phi_T\ l_\mathit{null}\rp \rp ] = \cfgnt{L}^\prime
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgt{new}\ \cfgnt{C}\rp \ \cfgnt{k}\rp  \rightarrow \\\\
      \lp \cfgnt{L}^\prime\ \cfgnt{R}^\prime\ \phi_g\ \eta\ \cfgnt{r}\ \cfgnt{k}\rp 
	}
\and
	\inferrule[Field Access(eval)]{}{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgnt{e}\ \cfgt{\$}\ \cfgnt{f}\rp \ \cfgnt{k}\rp  \rightarrow \\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}\ \lp \cfgt{init}\ \cfgnt{f}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp \rp 
	}
\and
    \inferrule[Equals (l-operand eval)]{}{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgnt{e}_0\ \cfgt{=}\ \cfgnt{e}\rp  \ \cfgnt{k}\rp  \rightarrow \\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_0\ \lp \cfgt{*}\ \cfgt{=}\; \cfgnt{e} \rightarrow \cfgnt{k}\rp \rp 
    }
\and
    \inferrule[Equals (r-operand eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{v}\ \lp \cfgt{*}\; \cfgt{=}\; \cfgnt{e} \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}\ \lp \cfgnt{v}\; \cfgt{=}\; \cfgt{*} \rightarrow \cfgnt{k}\rp \rp 
    }
\and
    \inferrule[Equals (bool)]{
    \cfgnt{v}_0 \in \{\cfgt{true}, \cfgt{false}\} \\
    \cfgnt{v}_1 \in \{\cfgt{true}, \cfgt{false}\} \\\\
    \mathrm{eq?}\lp v_0, v_1\rp  = \cfgnt{v}_r}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{v}_0\ \lp \cfgnt{v}_1\; \cfgt{=}\; \cfgt{*} \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{v}_r\ \cfgnt{k}\rp 
    }
\and
   \inferrule[Method Invocation (object eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp\cfgnt{e}_0\ \cfgt{@}\ \cfgnt{m}\ \cfgnt{e}_1\rp\ \cfgnt{k}\rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_0\ \lp \cfgt{*}\ \cfgt{@}\ \cfgnt{m}\ \cfgnt{e}_1\ \rightarrow \cfgnt{k}\rp \rp 
   }
   
\and
   \inferrule[Method Invocation (arg eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{v}_0\ \lp \cfgt{*}\ \cfgt{@}\ \cfgnt{m}\ \cfgnt{e}_1\ \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_1\ \lp \cfgnt{v}_0\ \cfgt{@}\ \cfgnt{m}\ \cfgt{*}\ \rightarrow \cfgnt{k}\rp \rp 
   }
\and
   \inferrule[Method Invocation]{
    \mathrm{lookup}\lp \cfgnt{m}\rp  = \lp\cfgnt{T}\ \cfgnt{m}\ \lb\cfgnt{T}\ \cfgnt{x}\rb\ \ \cfgnt{e}_m\rp \\\\
    \eta[\cfgt{this} \mapsto \cfgnt{v}_0][\cfgnt{x} \mapsto \cfgnt{v}_1] = \eta_m}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{v}_1\ \lp \cfgnt{v}_0\ \cfgt{@}\ \cfgnt{m}\ \cfgt{*}\ \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta_m\ \cfgnt{e}_m\ \lp \cfgt{pop}\ \eta\ \cfgnt{k}\rp \rp 
   }
\and
    \inferrule[If-then-else (eval)]{}{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgt{if}\ \cfgnt{e}_0\ \cfgnt{e}_1\ \cfgt{else}\ \cfgnt{e}_2\rp \ \cfgnt{k}\rp  \rightarrow \\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_0\ \lp \cfgt{if}\ \cfgt{*}\ \cfgnt{e}_1\ \cfgt{else}\ \cfgnt{e}_2\rp  \rightarrow \cfgnt{k}\rp 
	}
\and
	\inferrule[If-then-else (true) ]{}{
       \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgt{true}\ \lp \cfgt{if}\ \cfgt{*}\ \cfgnt{e}_1\ \cfgt{else}\ \cfgnt{e}_2\rp  \rightarrow \cfgnt{k}\rp  \rightarrow \\\\
       \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_1\  \cfgnt{k}\rp 
	}
\and
	\inferrule[If-then-else (false)]{}{
       \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgt{false}\ \lp \cfgt{if}\ \cfgt{*}\ \cfgnt{e}_1\ \cfgt{else}\ \cfgnt{e}_2\rp  \rightarrow \cfgnt{k}\rp  \rightarrow \\\\
       \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_2\  \cfgnt{k}\rp 
	}
\and
	\inferrule[Field Write (eval)]{}{
       \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgnt{x}\ \cfgt{\$}\ \cfgnt{f}\ \cfgt{:=}\ \cfgnt{e}\rp \ \cfgnt{k}\rp  \rightarrow \\\\
       \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}\ \lp \cfgt{init}\ \cfgnt{f}\ \lp \cfgnt{x}\ \cfgt{\$}\ \cfgnt{f}\ \cfgt{:=}\ \cfgt{*}\ \rightarrow\ \cfgnt{k}\rp \rp \rp 
	}
\and
   \inferrule[Begin (no args)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgt{begin}\rp \ \cfgnt{k}\rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{k}\rp 
   }
\and
   \inferrule[Begin (arg0 eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgt{begin}\ \cfgnt{e}_0\ \cfgnt{e}_1\ ...\rp \ \cfgnt{k}\rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_0\ \lp \cfgt{begin}\ \cfgt{*}\ \lp\cfgnt{e}_1\ ...\rp \rightarrow \cfgnt{k}\rp \rp 
   }
\and
   \inferrule[Begin (argi eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ v\ \lp \cfgt{begin}\ \cfgt{*}\ \lp\cfgnt{e}_i\ \cfgnt{e}_{i+1}\ ...\rp \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_i\ \lp \cfgt{begin}\ \cfgt{*}\ \lp\cfgnt{e}_{i+1}\ ...\rp \rightarrow \cfgnt{k}\rp \rp 
   }
\and
   \inferrule[Begin (argN eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ v\ \lp \cfgt{begin}\ \cfgt{*}\ \lp\cfgnt{e}_{n}\rp \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_n\ \lp \cfgt{begin}\ \cfgt{*}\ \lp\rp \rightarrow \cfgnt{k}\rp \rp 
   }
\and
   \inferrule[Begin]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ v\ \lp \cfgt{begin}\ \cfgt{*}\ \lp\rp \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ v\ \cfgnt{k}\rp 
   }	
\and
   \inferrule[Variable Declaration (eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp\cfgt{var}\ \cfgnt{T}\ \cfgnt{x}\ \cfgt{:=}\ \cfgnt{e}_0\ \cfgt{in}\ \cfgnt{e}_1\rp\ \cfgnt{k}\rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}_0\ \lp\cfgt{var}\ \cfgnt{T}\ \cfgnt{x}\ \cfgt{:=}\ \cfgt{*}\ \cfgt{in}\ \cfgnt{e}_1 \rightarrow \cfgnt{k}\rp\rp 
   }	
\and
   \inferrule[Variable Declaration]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ v\ \lp\cfgt{var}\ \cfgnt{T}\ \cfgnt{x}\ \cfgt{*}\ \cfgt{:=}\ \cfgt{in}\ \cfgnt{e}_1 \rightarrow \cfgnt{k}\rp\rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta[x \mapsto v]\ \cfgnt{e}_1\ \lp \cfgt{pop}\ \eta\ \cfgnt{k}\rp \rp 
   }	
\and
   \inferrule[Variable Assignment (eval)]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgnt{x}\ \cfgt{:=}\ \cfgnt{e}\rp \ \cfgnt{k}\rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{e}\ \lp \cfgnt{x}\ \cfgt{:=}\ \cfgt{*} \rightarrow\ \cfgnt{k}\rp \rp 
   }	
\and
   \inferrule[Variable Assignment]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ v\ \lp \cfgnt{x}\ \cfgt{:=}\ \cfgt{*} \rightarrow\ \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta[\cfgnt{x} \mapsto \cfgnt{v}]\ v\ \cfgnt{k}\rp 
   }	
\and
   \inferrule[Pop]{}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \lp \cfgt{pop}\ \eta_0\ \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta_0\ \cfgnt{k}\rp 
   }
\end{mathpar}
\end{center}
\caption{Rules common for classic symbolic execution with lazy initialization and symbolic execution with the fully symbolic heap.}
\label{fig:general}
\end{figure*}

\begin{figure*}[t]
\begin{center}
\mprset{flushleft}
\begin{mathpar}
	\inferrule[Initialize (null)]{
	  \Lambda = \{ l \mid \exists \phi\ \lp \lp \phi\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp  \wedge  \cfgnt{R}\lp l,\cfgnt{f}\rp  = \bot\ \rp\}\\
      \Lambda \neq \emptyset\\\\
      \cfgnt{r}^\prime = \mathrm{fresh}_r\lp \rp\\ 
      \theta_\mathit{null} = \{ \lp \phi_T\ l_\mathit{null}\rp \} \\
      l_x = \mathrm{min}_l\lp \Lambda\rp \\\\
      \phi_g^\prime = \lp\phi_g \wedge \cfgnt{r}^\prime = \cfgnt{r}_\mathit{null}\rp
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \cfgnt{r}\ \cfgnt{f}\rp  \rightarrow_I 
      \lp \cfgnt{L}[\cfgnt{r}^\prime \mapsto \theta_\mathit{null}]\ \cfgnt{R}[ \lp l_x,\cfgnt{f}\rp  \mapsto \cfgnt{r}^\prime]\ \phi_g^\prime\ \cfgnt{r}\ \cfgnt{f}\rp 
	}
\and
	\inferrule[Initialize (new)]{
	  \Lambda  = \{ l \mid \exists \phi\ \lp \lp \phi\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp  \wedge  \cfgnt{R}\lp l,\cfgnt{f}\rp  = \bot\rp\}\\
      \Lambda \neq \emptyset\\\\
      \mathrm{C} = \mathrm{type}\lp \cfgnt{f}\rp\\
      \cfgnt{r}_f = \mathrm{init}_r\lp \rp\\
      l_f = \mathrm{init}_l\lp \mathrm{C}\rp \\\\
      \rho = \{ \lp\cfgnt{r}_a\ l_a\rp \mid \mathrm{isInit}\lp \cfgnt{r}_a\rp  \wedge \mathrm{type}\lp l_a\rp  = \mathrm{C} \wedge \exists \phi_a\ \lp \lp \phi_a\ l_a\rp  \in \cfgnt{L}\lp \cfgnt{r}_a\rp\rp \}\\\\
      \theta_\mathit{new} = \{\lp \phi_T\ l_f\rp \} \\
      l_x = \mathrm{min}_l\lp \Lambda\rp \\\\
      \phi_g^\prime = \lp\phi_g \wedge \cfgnt{r}_f \neq \cfgnt{r}_\mathit{null} \wedge \lp \wedge_{\lp\cfgnt{r}_a\ l_a\rp \in \rho} \cfgnt{r}_f \ne \cfgnt{r}_a\rp\rp
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \cfgnt{r}\ \cfgnt{f}\rp  \rightarrow_I 
      \lp \cfgnt{L}[\cfgnt{r}_f \mapsto \theta_\mathit{new}]\ \cfgnt{R}[ \lp l_x,\cfgnt{f}\rp  \mapsto \cfgnt{r}_f ]\ \phi_g^\prime\ \cfgnt{r}\ \cfgnt{f}\rp 
	}
\and
	\inferrule[Initialize (alias)]{
	  \Lambda = \{ l \mid \exists \phi\ \lp \lp \phi\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp  \wedge  \cfgnt{R}\lp l,\cfgnt{f}\rp  = \bot\ \rp\}\\
      \Lambda \neq \emptyset\\\\
      \mathrm{C} = \mathrm{type}\lp \cfgnt{f}\rp\\
      \cfgnt{r}^\prime = \mathrm{fresh}_r\lp \rp\\\\
      \rho = \{ \lp\cfgnt{r}_a\ l_a\rp \mid \mathrm{isInit}\lp \cfgnt{r}_a\rp  \wedge \mathrm{type}\lp l_a\rp  = \mathrm{C} \wedge \exists \phi_a\ \lp \lp \phi_a\ l_a\rp  \in \cfgnt{L}\lp \cfgnt{r}_a\rp\rp \}\\\\
      \lp\cfgnt{r}_a\ l_a\rp \in \rho \\
      \theta_\mathit{alias} = \{ \lp \phi_T\ l_a\rp\}\\
      l_x = \mathrm{min}_l\lp \Lambda\rp\\\\
      \phi^\prime_g = \lp\phi_g \wedge \cfgnt{r}^\prime \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}^\prime = \cfgnt{r}_a \wedge \lp \wedge_{\lp \cfgnt{r}^{\prime}_a\ l_a\rp  \in \rho\ \lp \cfgnt{r}^{\prime}_a \neq \cfgnt{r}_a\rp } \cfgnt{r}^\prime \neq \cfgnt{r}^{\prime}_a \rp\rp
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \cfgnt{r}\ \cfgnt{f}\rp  \rightarrow_I 
      \lp \cfgnt{L}[\cfgnt{r}^\prime \mapsto \theta_\mathit{alias}]\ \cfgnt{R}[ \lp l_x,\cfgnt{f}\rp  \mapsto \cfgnt{r}^\prime ]\ \phi_g^\prime\ \cfgnt{r}\ \cfgnt{f}\rp 
	}
\end{mathpar}
\end{center}
\caption{The initialization machine, $s ::= \lp\cfgnt{L}\ \cfgnt{R}\ \phi_g\ \cfgnt{r}\ \cfgnt{f}\rp$,
for generalized symbolic execution with lazy initialization denoted by $\rightarrow_I$.}
\label{fig:lazyInit}
\end{figure*}

\begin{figure*}[t]
\begin{center}
\mprset{flushleft}
\begin{mathpar}
	\inferrule[Field Access]{
      \{\lp\phi\ l\rp\} = \cfgnt{L}\lp\cfgnt{r}\rp\\
      l \neq \cfgnt{l}_\mathit{null}\\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \cfgnt{r}\ \cfgnt{f}\rp \rightarrow^*_I 
      \lp \cfgnt{L}^\prime\ \cfgnt{R}^\prime\ \phi_g^\prime\ \cfgnt{r}\ \cfgnt{f} \rp \\\\ 
      \{\lp\phi^\prime\ l^\prime\rp\} = \cfgnt{L}^\prime\lp\cfgnt{R}^\prime\lp l,\cfgnt{f}\rp\rp \\
      \mathrm{fresh}_r\lp\rp  = \cfgnt{r}^\prime \\
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
      \lp \cfgnt{L}^\prime[\cfgnt{r}^\prime \mapsto \lp\phi^\prime\ l^\prime\rp]\ \cfgnt{R}^\prime\ \phi_g^\prime\ \eta\ \cfgnt{r}^\prime\ \cfgnt{k}\rp 
	}
\and
	\inferrule[Field Write]{
      \cfgnt{r}_x = \eta\lp \cfgnt{x}\rp\\ 
      \{\lp\phi\ l\rp\} = \cfgnt{L}\lp\cfgnt{r}_x\rp \\
      l \neq \cfgnt{l}_\mathit{null}\\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \cfgnt{r}_x\ \cfgnt{f}\rp \rightarrow^*_I 
      \lp \cfgnt{L}^\prime\ \cfgnt{R}^\prime\ \phi_g^\prime\ \cfgnt{r}_x\ \cfgnt{f} \rp \\\\ 
      \mathrm{fresh}_r\lp\rp = \cfgnt{r}^\prime\\
      \theta =  \cfgnt{L}^\prime\lp\cfgnt{r}\rp 
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}\ \lp \cfgnt{x}\ \cfgt{\$}\ \cfgnt{f}\ \cfgt{:=}\ \cfgt{*}\ \rightarrow\ \cfgnt{k}\rp \rp  \rightarrow \\\\
      \lp \cfgnt{L}^\prime[\cfgnt{r}^{\prime} \mapsto \theta]\ \cfgnt{R}^\prime[\lp l\ \cfgnt{f}\rp  \mapsto \cfgnt{r}^\prime]\ \phi_g\ \eta\ \cfgnt{r}^\prime\ \cfgnt{k}\rp 
	}	
\and
    \inferrule[Equals (reference-true)]{
    \cfgnt{L}\lp \cfgnt{r}_0\rp = \cfgnt{L}\lp \cfgnt{r}_1\rp\\
    \phi_g^\prime = \lp\phi_g \wedge r_0 = r_1\rp
    }{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}_0\ \lp \cfgnt{r}_1\ \cfgt{=}\ \cfgt{*} \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g^\prime\ \eta\ \cfgt{true}\ \cfgnt{k}\rp 
    }
\and
    \inferrule[Equals (reference-false)]{
    \cfgnt{L}\lp \cfgnt{r}_0\rp \neq \cfgnt{L}\lp \cfgnt{r}_1\rp\\
    \phi_g^\prime = \lp\phi_g \wedge r_0 \neq r_1\rp
   }{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}_0\ \lp \cfgnt{r}_1\ \cfgt{=}\ \cfgt{*} \rightarrow \cfgnt{k}\rp \rp  \rightarrow \\\\
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g^\prime\ \eta\ \cfgt{false}\ \cfgnt{k}\rp 
    }
\end{mathpar}
\end{center}
\caption{Generalized symbolic execution with lazy initialization.}
\label{fig:lazy}
\end{figure*}

\begin{figure*}[t]
\begin{center}
\mprset{flushleft}
\begin{mathpar}
	\inferrule[Summarize]{
	  \Lambda = \{ l \mid \exists \phi\ \lp \lp \phi\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp\wedge l \neq l_\mathit{null}  \wedge  \cfgnt{R}\lp l,\cfgnt{f}\rp  = \bot\ \rp\}\\
      \Lambda \neq \emptyset \\\\
      \mathrm{C} = \mathrm{type}\lp \cfgnt{f}\rp \\
      \cfgnt{r}_f = \mathrm{init}_r\lp \rp \\
      l_f  = \mathrm{init}_l\lp \mathrm{C}\rp\\\\
      \rho = \{ \lp \cfgnt{r}_a\ \phi_a\ l_a\rp  \mid \mathrm{isInit}\lp \cfgnt{r}_a\rp  \wedge \lp \phi_a\ l_a\rp  \in \cfgnt{L}\lp \cfgnt{r}_a\rp \wedge \mathrm{type}\lp l_a\rp  = \mathrm{C} \} \\\\
      \theta_\mathit{alias} = \{ \lp \phi\ l_a\rp  \mid \exists\cfgnt{r}_a\ \lp\exists \phi_a\ \lp\lp\cfgnt{r}_a\ \phi_a\ l_a\rp  \in \rho \wedge \phi = \lp \phi_a \wedge \cfgnt{r}_f \neq \cfgnt{r}_\mathit{null} \wedge \cfgnt{r}_f = \cfgnt{r}_a \wedge \lp \wedge_{\lp \cfgnt{r}^{\prime}_a\ \phi^{\prime}_a\ l^{\prime}_a\rp  \in \rho\ \lp \cfgnt{r}^\prime_a \neq \cfgnt{r}_a\rp } \cfgnt{r}_f \neq \cfgnt{r}^{\prime}_a \rp \rp \rp \rp \} \\\\
      \theta_\mathit{new} = \{\lp \phi\ l_f\rp  \mid \phi = \lp \cfgnt{r}_f \neq \cfgnt{r}_\mathit{null} \wedge \lp \wedge_{\lp \cfgnt{r}^\prime_a,\ \phi^\prime_a,\ l^\prime_a\rp  \in \rho} \cfgnt{r}_f \ne \cfgnt{r}^\prime_a\rp \rp \}\\\\
      \theta_\mathit{null} = \{ \lp \phi\ l_\mathit{null}\rp  \mid \phi = \lp \cfgnt{r}_f = \cfgnt{r}_\mathit{null}\rp  \}\\\\
      \theta = \theta_\mathit{alias} \cup \theta_\mathit{new} \cup \theta_\mathit{null} \\
      l_x = \mathrm{min}_l\lp \Lambda\rp 
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \cfgnt{r}\ \cfgnt{f}\rp \rightarrow_S 
      \lp \cfgnt{L}[\cfgnt{r}_f \mapsto \theta]\ \cfgnt{R}[ \lp l_x,\cfgnt{f}\rp  \mapsto \cfgnt{r}_f ]\ \cfgnt{r}\ \cfgnt{f}\ \rp
	}
\end{mathpar}
\end{center}
\caption{The summary machine, $s ::= \lp\cfgnt{L}\ \cfgnt{R}\ \cfgnt{r}\ \cfgnt{f}\rp$,
for precise heap summaries from symbolic execution denoted $\rightarrow_S$.}
\label{fig:symInit}
\end{figure*}

\begin{figure*}[t]
\begin{center}
\mprset{flushleft}
\begin{mathpar}
	\inferrule[Field Access]{
      \forall \lp \phi\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp \ \lp l = l_{\mathit{null}} \rightarrow \neg \mathbb{S}\lp \phi \wedge \phi_g\rp \rp  \\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \cfgnt{r}\ \cfgnt{f}\rp \rightarrow^*_S \lp \cfgnt{L}^\prime\ \cfgnt{R}^\prime\ \cfgnt{r}\ \cfgnt{f}\rp \\
      \cfgnt{r}^\prime = \mathrm{fresh}_r\lp \rp
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}\ \lp \cfgt{*}\ \cfgt{\$}\ \cfgnt{f} \rightarrow \cfgnt{k}\rp \rp  \rightarrow 
      \lp \cfgnt{L}^\prime[\cfgnt{r}^\prime \mapsto \mathbb{VS}\lp \cfgnt{L}^\prime,\cfgnt{R}^\prime,\cfgnt{r},\cfgnt{f},\phi_g\rp ]\ \cfgnt{R}^\prime\ \phi_g\ \eta\ \cfgnt{r}^\prime\ \cfgnt{k}\rp 
	}
\and
	\inferrule[Field Write]{
	\cfgnt{r}_x = \eta\lp \cfgnt{x}\rp \\
\forall \lp \phi\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}_x\rp \ \lp l = l_{\mathit{null}} \rightarrow \neg \mathbb{S}\lp \phi \wedge \phi_g\rp \rp  \\\\
      \lp \cfgnt{L}\ \cfgnt{R}\ \cfgnt{r}_x\ \cfgnt{f}\rp \rightarrow^*_S \lp \cfgnt{L}^\prime\ \cfgnt{R}^\prime\ \cfgnt{r}_x\ \cfgnt{f}\rp \\\\
      \Psi_x =\{\lp \cfgnt{r}_\mathit{old}\ \phi\ l\rp  \mid \lp \phi\ \cfgnt{l}\rp  \in \cfgnt{L}^\prime\lp \cfgnt{r}_x\rp  \wedge \cfgnt{r}_\mathit{old} \in \cfgnt{R}\lp l,\cfgnt{f}\rp  \}\\\\
      X = \{ \lp \cfgnt{r}_\mathit{old}\ \theta\ l\rp  \mid \exists \phi\ \lp \lp \cfgnt{r}_\mathit{old}\ \phi\ l\rp \in \Psi_x \wedge \theta = \mathbb{ST}\lp \cfgnt{L}^\prime,\cfgnt{r},\phi\rp  \cup \mathbb{ST}\lp \cfgnt{L}^\prime,\cfgnt{r}_\mathit{old},\neg\phi\rp \rp  \}\\\\
      \cfgnt{R}^{\prime\prime} = \cfgnt{R}^\prime[\forall \lp \cfgnt{r}_\mathit{old}\ \theta\ l\rp  \in X\ \lp \lp l\ \cfgnt{f}\rp  \mapsto \mathrm{fresh}_r\lp \rp \rp ]\\\\
      \cfgnt{L}^{\prime\prime} = \cfgnt{L}^\prime[\forall \lp \cfgnt{r}_\mathit{old}\ \theta\ l\rp  \in X\ \lp \exists \cfgnt{r}^{\prime}\ \lp \cfgnt{r}^\prime = \cfgnt{R}^\prime\lp l,\cfgnt{f}\rp \wedge \lp\cfgnt{r}^{\prime} \mapsto \theta\rp  \rp \rp ]
    }{
      \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}\ \lp \cfgnt{x}\ \cfgt{\$}\ \cfgnt{f}\ \cfgt{:=}\ \cfgt{*}\ \rightarrow\ \cfgnt{k}\rp \rp  \rightarrow 
      \lp \cfgnt{L}^{\prime\prime} \cfgnt{R}^{\prime\prime}\ \phi_g\ \eta\ \cfgnt{k}\rp 
	}	
\and
    \inferrule[Equals (references-true)]{
    \theta_\alpha = \{\phi_0 \wedge \phi_1 \mid \exists l\ \lp \lp \phi_0\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}_0\rp  \wedge \lp \phi_1\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}_1\rp \rp \} \\\\
    \theta_0 = \{\phi_0 \mid \exists l_0\ \lp \lp \phi_0\ l_0\rp  \in \cfgnt{L}\lp \cfgnt{r}_0\rp  \wedge \forall \lp \phi_1\ l_1\rp  \in \cfgnt{L}\lp \cfgnt{r}_1\rp \ \lp l_0 \neq l_1\rp \rp \} \\\\
    \theta_1 = \{\phi_1 \mid \exists l_1\ \lp \lp \phi_1\ l_1\rp  \in \cfgnt{L}\lp \cfgnt{r}_1\rp  \wedge \forall \lp \phi_0\ l_0\rp  \in \cfgnt{L}\lp \cfgnt{r}_0\rp \ \lp l_0 \neq l_1\rp \rp \} \\\\
    \phi_g^\prime =  \phi_g \wedge \lp \vee_{\phi_\alpha\in\theta_\alpha}\phi_\alpha\rp \wedge\lp \wedge_{\phi_0 \in \theta_0} \neg \phi_0\rp \wedge\lp \wedge_{\phi_1
    \in \theta_1} \neg \phi_1\rp \\\\ \mathbb{S}(\phi_g^\prime)}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}_0\ \lp \cfgnt{r}_1\; \cfgt{=}\; \cfgt{*} \rightarrow \cfgnt{k}\rp \rp  \rightarrow
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g^\prime\ \eta\ \cfgt{true}\ \cfgnt{k}\rp 
    }
\and
    \inferrule[Equals (references-false)]{
    \theta_\alpha = \{\phi_0 \rightarrow \neg \phi_1 \mid \exists l\ \lp \lp \phi_0\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}_0\rp  \wedge \lp \phi_1\ l\rp  \in \cfgnt{L}\lp \cfgnt{r}_1\rp \rp \} \\\\
    \theta_0 = \{\phi_0 \mid \exists l_0\ \lp \lp \phi_0\ l_0\rp  \in \cfgnt{L}\lp \cfgnt{r}_0\rp  \wedge \forall \lp \phi_1\ l_1\rp  \in \cfgnt{L}\lp \cfgnt{r}_1\rp \ \lp l_0 \neq l_1\rp \rp \} \\\\
    \theta_1 = \{\phi_1 \mid \exists l_1\ \lp \lp \phi_1\ l_1\rp  \in \cfgnt{L}\lp \cfgnt{r}_1\rp  \wedge \forall \lp \phi_0\ l_0\rp  \in \cfgnt{L}\lp \cfgnt{r}_0\rp \ \lp l_0 \neq l_1\rp \rp \} \\\\
    \phi_g^\prime = \phi_g \wedge \lp \wedge_{\phi_\alpha\in\theta_\alpha}\phi_\alpha\rp \vee\lp \lp \vee_{\phi_0 \in \theta_0} \phi_0\rp   \vee\lp \vee_{\phi_1
    \in \theta_1} \phi_1\rp \rp  \\\\ \mathbb{S}(\phi_g^\prime)}{
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g\ \eta\ \cfgnt{r}_0\ \lp \cfgnt{r}_1\; \cfgt{=}\; \cfgt{*} \rightarrow \cfgnt{k}\rp \rp  \rightarrow
    \lp \cfgnt{L}\ \cfgnt{R}\ \phi_g^\prime\ \eta\ \cfgt{false}\ \cfgnt{k}\rp 
    }
\end{mathpar}
\end{center}
\caption{Precise symbolic heap summaries from symbolic execution.}
\label{fig:sym}
\end{figure*}



