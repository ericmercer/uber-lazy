\section{Evaluation}
\label{sec:evaluation}
%\begin{figure*}[t]
\begin{table*} [t]
  \centering
  \scalebox{0.88}{\begin{tabular}{| c | c | r | r | r | r | r | r | r | r | r |}
  \hline
   \multirow{2}{*}{Method }&\multirow{2}{*}{ $k$ }
   &\multicolumn{3}{c|}{Time (seconds)} &\multicolumn{3}{c|}{States} &\multicolumn{3}{c|}{ Paths }\\
								&	&\gsetxt{} & L\#		&SL		&\gsetxt{}	& L\# & SL&\gsetxt{}	& L\# 	& SL\\
   \hline
    \multirow{3}{*}{LinkedList }			&3	& 0.91	& 1.21	& 0.69	& 2465	& 2844	& 99		&1656	& 1269	& 25\\
   		 						& 4	& 2.92	& 3.35	& 0.91	& 25774	& 29977	& 155	&17485	& 13550	& 39\\
   								& 5	& 20.78	& 19.47	& 1.59	& 341164	& 400296	& 223	&232743	& 181849	& 56\\
								& 6	& 280.56	& 299.19	& 2.36	&5447980	&6437201	& 303	&3731094	&2933027	& 76\\
								& 7	& -		& -		& 5.07	& -		&-		& 395	&-		&-		& 99\\
								& 8	& -		& -		& 17.49	& -		&-		& 499	&-		&-		& 125\\
								& 9	& -		& -		& 63.96	& -		&-		& 615	&-		&-		& 154\\
								& 10	& -		& -		& 206.93	& -		&-		& 743	&-		&-		& 186\\
    \hline
    \multirow{3}{*}{BinarySearchTree }	& 1	& 0.26	& 0.28	& 0.36	& 19		& 23		& 29		& 6		& 6		& 6\\
   		 						& 2	& 0.83	& 1.28	& 0.93	& 143	& 143	& 145	& 43		& 42		& 33\\
   								& 3	& 20.63	& 25.55	& 4.03	& 1953	& 1703	& 1485	& 515	& 515	& 328\\
								& 4	& -		& -		& 410.89	& -		&-		& 73635	&-		&-		& 15563\\
    \hline
      \multirow{3}{*}{TreeMap}			& 1	& 0.47	& 0.52	& 0.77	& 65		& 70		& 215	& 11		& 11		& 11\\
   		 						& 2	& 8.99	& 9.73	& 4.72	& 1009	& 942	& 3219	& 127	& 122	& 73\\
   								& 3	& -		& -		& 145.56	& -		& -		& 78695	& -		& -		& 887\\
						
    \hline
  \end{tabular}}
  \caption{Comparing the efficiency of the symbolic heap with the~\gsetxt{} and Lazier\# algorithms.}
  \label{tab:results}
\end{table*}

%\end{figure*}

%\subsection{Analysis}
Although the correctness of~\symtxt{} has been demonstrated,
it remains an open question whether it represents a practical alternative to the
case-splitting methods currently in use. It is possible 
that the benefit of decreasing the number of paths explored is
offset by the increased complexity of the resulting path condition. 

To resolve this question, we implemented a prototype of the \symtxt{} 
algorithm in Symbolic PathFinder (SPF)~\cite{DBLP:journals/ase/PasareanuVBGMR13} 
and evaluate its efficacy on Java data structure artifacts.
%SPF includes an implementation of~\gsetxt{} with lazy initialization.
%In recent work, we implemented the  Lazier and Lazier\#
%algorithms in SPF~\cite{Hillery:2014}.
%
%The prototype of our~\symtxt{} algorithm is implemented as an
%extension to SPF.  
In addition to the operations presented in
this paper, the implementation contains support for operations over
integers, calculating per-path preconditions 
and postconditions, as well as path-coverage-optimal sets of 
test input heaps. 
%A standalone version of the system, independent
%from JPF is also under development~\cite{heapsolver2015}.

The data structures used in the benchmarks are a standard set commonly used in analyses involving heap-manipulating programs~\cite{Deng:2006,Deng:2007,boyapati2002korat,Ferrara:2014,Rosner:2015}, including a linked list, binary search tree, and red/black tree. The BinarySearchTree test uses the class of the same name from Alan Weiss' book~\cite{Weiss:1998}. The test method first asserts a repOk() invariant, before conducting a traversal to find an arbitrary integer key in the tree. The TreeMap method comes from the standard java.util library, and is an implementation of a balanced red/black tree. This method asserts a repOk() invariant, before traversing the tree. The LinkedList test starts by asserting a repOk() invariant, which checks for loops in the linked list using Floyd’s cycle-finding algorithm. The linked list is then traversed using a contains() method that attempts to locate an arbitrary reference key in the list. For benchmarking purposes, the length of reference chain initializations was limited to some integer $k$. For both the tree examples, the number of possible non-isomorphic tree structures grows exponentially in k~\cite{Deng:2007}, resulting a corresponding exponential growth in analysis times for case-splitting techniques.

The results of the experiments are presented in Table~\ref{tab:results}. 
Each row reports the results for the specified $k$-bound 
for each artifact evaluated. The columns show the total
time in seconds, states explored, and paths generated for
each algorithm. The headings \gsetxt{}, L\#, and SH correspond
to the Generalized Symbolic Execution, Lazier\#, and \symtxt{}
algorithms, respectively. Note that we omit the results for
the Lazier algorithm because they are nearly identical to the Lazier\#
results for these artifacts. A table entry of  '-' indicates the analysis
exceeded the allotted time bound of 1 hour.

Performance improvement ranges from $4.8x$ for
BinarySearchTree at $k$=3, to $118x$ for LinkedList at $k$=6. In fact,
for some $k$-bounds a number of experiments complete exploration
using the \symtxt{} algorithm in a few seconds whereas \gsetxt{} or Lazier\# are
unable to finish, e.g., BinarySearchTree for $k$=4 and LinkedList for
$k$=8. The results demonstrate that for these common data structures,
the complexity of the constraints generated by~\symtxt{} is more 
than offset by the reduction in paths explored. 


%how does the per-path cost look for our method

%The number of states explored varies between algorithms. For example,
%\gsetxt{} creates additional points of nondeterminism during field reads, 
%while reference compares are completely deterministic. Thus, in
%example programs with large numbers of reference compares, e.g.,
%TreeMap, state counts for Lazier\# and the \symtxt{} algorithm may
%exceed those for \gsetxt{}. We observed that the additional states
%generated by the symbolic heap algorithm are unsatisfiable at the point
%of reference compares; this is why they do not contribute any
%additional branches in the final symbolic execution tree. Furthermore,
%the since larger state count is essentially a result of bookkeeping, it
%does not impact the overall runtime of the
%technique.


% Some of this discrepancy may be accounted for by the fact that
%\symtxt{} is equipped for incremental solving, however, during
%informal testing with the incremental solver turned off, \symtxt{}
%usually performed better than \gsetxt{} and Lazier\#, especially in
%test runs with high k-bounds.

%The path counts shown in Table~\ref{tab:results} also show the advantage
%of the \symtxt{} algorithm over the \gsetxt{} and L\# algorithms, each of
%which performs case-splitting during the analysis.
%The number of paths explored by the \symtxt{} algorithm is strictly 
%less than or equal to the number
%of paths explored by \gsetxt{} for all artifacts. As a result,
%fewer test cases will be generated to achieve the same control-flow 
%path coverage when compared to~\gsetxt{} and Lazier\#.

%In summary, the benefits of avoiding
%initialization-based non-determinism outweigh the increased
%complexity in the constraints due to the advances made in SMT
%solvers in these examples. In fact, the \symtxt{} algorithm can analyze certain types of programs with
%orders of magnitude greater efficiency than with \gsetxt{} or
%Lazier\#, while covering exactly the same control flow paths. 

%We can use this
%result to do more efficient test case generation. From a path
%generated we can use the solutions provided by the constraint solver
%to instantiate a set of concrete heaps to provide as test input. 


%Interestingly, \symtxt{} path growth appears
%to be sub-exponential in $k$ for the LinkedList program.




%The additional states generated by summary heap are unsatisfiable
%which is why they do not add nodes in the final symbolic execution
%tree. Furthermore, the larger state count does not impact the overall
%runtime of the technique.

% Despite this, in practice this is often mitigated by the
%fact that \symtxt{} can dispatch address compares without consulting
%the constraint solver.


