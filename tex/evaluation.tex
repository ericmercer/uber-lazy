%\begin{figure*}[t]
\begin{table*} [t]
  \centering
  \scalebox{0.88}{\begin{tabular}{| c | c | r | r | r | r | r | r | r | r | r |}
  \hline
   \multirow{2}{*}{Method }&\multirow{2}{*}{ $k$ }
   &\multicolumn{3}{|c|}{Time} &\multicolumn{3}{|c|}{States} &\multicolumn{3}{|c|}{ Paths }\\
								&	&\gsetxt{} & L\#		&SL		&\gsetxt{}	& L\# & SL&\gsetxt{}	& L\# 	& SL\\
   \hline
    \multirow{3}{*}{LinkedList }			&3	& 0.91	& 1.21	& 0.69	& 2465	& 2844	& 99		&1656	& 1269	& 25\\
   		 						& 4	& 2.92	& 3.35	& 0.91	& 25774	& 29977	& 155	&17485	& 13550	& 39\\
   								& 5	& 20.78	& 19.47	& 1.59	& 341164	& 400296	& 223	&232743	& 181849	& 56\\
								& 6	& 280.56	& 299.19	& 2.36	&5447980	&6437201	& 303	&3731094	&2933027	& 76\\
    \hline
    \multirow{3}{*}{BinarySearchTree }	& 1	& 0.26	& 0.28	& 0.36	& 19		& 23		& 29		& 6		& 6		& 6\\
   		 						& 2	& 0.83	& 1.28	& 0.93	& 143	& 143	& 145	& 43		& 42		& 33\\
   								& 3	& 20.63	& 25.55	& 4.03	& 1953	& 1703	& 1485	& 515	& 515	& 328\\
    \hline
      \multirow{3}{*}{TreeMap}			& 1	& 0.47	& 0.52	& 0.77	& 65		& 70		& 215	& 11		& 11		& 11\\
   		 						& 2	& 8.99	& 9.73	& 4.72	& 1009	& 942	& 3219	& 127	& 122	& 73\\
   								& 3	& -		& -		& 145.56	& -		& -		& 78695	& -		& -		& 887\\
						
    \hline
  \end{tabular}}
  \caption{Comparing the efficiency of the summary heap appraoch to GSE and Lazier\# algorithms.}
  \label{tab:results}
\end{table*}
%\end{figure*}

%\subsection{Analysis}

The results of the experiments are presented in Table
\ref{tab:results}. The rows contain to individual $k$-bounded test
runs for each of the evaluated programs. The columns show the total
walk clock time in seconds, states explored, and paths generated for
each of the algorithms. The headings \gsetxt{}, L\#, and SL correspond
to the Generalized Symblic Execution, lazier\#, and \symtxt{}
algorithms, respectively. Note that we do no present the results for
lazier algorithm since they are almost identical to that of lazier\#
for our examples. Table entries containing - correspond to test runs
that exceeded the allotted time bounds. Each trial is time bounded to
10 mins.

In most tests, run times strongly favor \symtxt{}, especially for
large $k$-values. Performance improvement ranges from $4.8x$ for
BinarySearchTree at $k$=3, to $118x$ for LinkedList at $k$=6. In fact,
for certain $k$-bounds a number of experiments completed exploration
using \symtxt{} in a few seconds whereas \gsetxt{} or lazier\# were
unable to do, e.g., BinarySearchTree for $k$=4 and LinkedList for
$k$=8. These results demonstrate the potential of using \symtxt{} as
an approach to handle data input of complex types. The lower runtimes
show that we can prove properties using \symtxt{} faster compared to
\gsetxt{}.

% Some of this discrepancy may be accounted for by the fact that
%\symtxt{} is equipped for incremental solving, however, during
%informal testing with the incremental solver turned off, \symtxt{}
%usually performed better than \gsetxt{} and lazier\#, especially in
%test runs with high k-bounds.

Path counts likewise substantially favor \symtxt{}. The number of
paths explored by \symtxt{} is strictly less than or equal the number
of paths explored by \gsetxt{} for all test cases. We can use this
result to do more efficient test case generation. From a path
generated we can use the solutions provided by the constraint solver
to instantiate a set of concrete heaps to provide as test input. These
can provide a smaller test suite to achieve control-flow path coverage
compared to GSE and Lazier\#.


%Interestingly, \symtxt{} path growth appears
%to be sub-exponential in $k$ for the LinkedList program.

Curiously, the pattern established with run-times and path counts does
not hold true for state counts. State counts can vary between
algorithms, because states in JPF represent points of nondeterminism,
and each algorithm differs in this regard. For example, \gsetxt{} has
additional points of nondeterminism during field reads, but in
contrast references compares are completely deterministic. Thus, in
example programs with large numbers reference compares, such as
TreeMap, state counts for lazier\# and \symtxt{} may exceed those for
\gsetxt{}. The larger state count, however, does not contribute to the
runtime of the technique.

% Despite this, in practice this is often mitigated by the
%fact that \symtxt{} can dispatch address compares without consulting
%the constraint solver.

In summary, it appears that the benefits of avoiding
initialization-based nondeterminism more than outweigh the increased
complexity in the constraints due to the advances made in SMT
solvers. In fact, \symtxt{} can analyze certain types of programs with
orders of magnitude greater efficiency than with \gsetxt{} or
lazier\#, while covering exactly the same control flow paths. 
