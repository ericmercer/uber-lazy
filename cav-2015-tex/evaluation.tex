\section{Evaluation}

%\begin{figure*}[t]
\begin{table*} [t]
  \centering
  \scalebox{0.88}{\begin{tabular}{| c | c | r | r | r | r | r | r | r | r | r |}
  \hline
   \multirow{2}{*}{Method }&\multirow{2}{*}{ $k$ }
   &\multicolumn{3}{|c|}{Time (seconds)} &\multicolumn{3}{|c|}{States} &\multicolumn{3}{|c|}{ Paths }\\
								&	&\gsetxt{} & L\#		&SH		&\gsetxt{}	& L\# & SH&\gsetxt{}	& L\# 	& SH\\
   \hline
    \multirow{3}{*}{LinkedList }			&3	& 0.91	& 1.21	& 0.69	& 2465	& 2844	& 99		&1656	& 1269	& 25\\
   		 						& 4	& 2.92	& 3.35	& 0.91	& 25774	& 29977	& 155	&17485	& 13550	& 39\\
   								& 5	& 20.78	& 19.47	& 1.59	& 341164	& 400296	& 223	&232743	& 181849	& 56\\
								& 6	& 280.56	& 299.19	& 2.36	&5447980	&6437201	& 303	&3731094	&2933027	& 76\\
    \hline
    \multirow{3}{*}{BinarySearchTree }	& 1	& 0.26	& 0.28	& 0.36	& 19		& 23		& 29		& 6		& 6		& 6\\
   		 						& 2	& 0.83	& 1.28	& 0.93	& 143	& 143	& 145	& 43		& 42		& 33\\
   								& 3	& 20.63	& 25.55	& 4.03	& 1953	& 1703	& 1485	& 515	& 515	& 328\\
    \hline
      \multirow{3}{*}{TreeMap}			& 1	& 0.47	& 0.52	& 0.77	& 65		& 70		& 215	& 11		& 11		& 11\\
   		 						& 2	& 8.99	& 9.73	& 4.72	& 1009	& 942	& 3219	& 127	& 122	& 73\\
   								& 3	& -		& -		& 145.56	& -		& -		& 78695	& -		& -		& 887\\
						
    \hline
  \end{tabular}}
  \caption{Comparing the efficiency of the summary heap with the GSE and Lazier\# algorithms.}
  \label{tab:results}
\end{table*}
%\end{figure*}

%\subsection{Analysis}
We empirically evaluate the \symtxt{}
algorithm for analyzing programs with unbounded heap allocated
data in the context of symbolic execution.
To perform our evaluation we implemented a prototype of the \symtxt{} 
algorithm in Symbolic PathFinder (SPF)~\cite{DBLP:journals/ase/PasareanuVBGMR13} 
and evaluate its efficacy on three Java data structure artifacts.
SPF includes an implementation of GSE with lazy initialization.
In recent work, we implemented the  Lazier and Lazier\#
algorithms in SPF~\cite{Hillery:2014}.

The results of the experiments are presented in Table~\ref{tab:results}. 
Each row reports the results for the specified $k$-bound 
for each artifact evaluated. The columns show the total
wall clock time in seconds, states explored, and paths generated for
each algorithm. The headings \gsetxt{}, L\#, and SH correspond
to the Generalized Symbolic Execution, Lazier\#, and \symtxt{}
algorithms, respectively. Note that we omit the results for
the Lazier algorithm because they are nearly identical to the Lazier\#
results for these artifacts. A table entry of  '-' indicates the analysis
exceeded the allotted time bound of 10 minutes.

The results in Table~\ref{tab:results} demonstrate the efficiency of the 
\symtxt{} algorithm, especially for
large $k$-values. Performance improvement ranges from $4.8x$ for
BinarySearchTree at $k$=3, to $118x$ for LinkedList at $k$=6. In fact,
for some $k$-bounds a number of experiments completed exploration
using the \symtxt{} algorithm in a few seconds whereas \gsetxt{} or Lazier\# were
unable to finish, e.g., BinarySearchTree for $k$=4 and LinkedList for
$k$=8. These results demonstrate the potential of using the \symtxt{} algorithm 
to analyze programs with complex types. The lower running times
show that we can prove properties using the \symtxt{} algorithm 
faster than \gsetxt{}.

The number of states explored varies between algorithms. For example,
\gsetxt{} creates additional points of nondeterminism during field reads, 
while reference compares are completely deterministic. Thus, in
example programs with large numbers of reference compares, e.g.,
TreeMap, state counts for Lazier\# and the \symtxt{} algorithm may
exceed those for \gsetxt{}. We observed that the additional states
generated by the summary heap algorithm are unsatisfiable at the point
of reference compares; this is why they do not contribute any
additional branches in the final symbolic execution tree. Furthermore,
the larger state count does not impact the overall runtime of the
technique.

% Some of this discrepancy may be accounted for by the fact that
%\symtxt{} is equipped for incremental solving, however, during
%informal testing with the incremental solver turned off, \symtxt{}
%usually performed better than \gsetxt{} and Lazier\#, especially in
%test runs with high k-bounds.

The path counts shown in Table~\ref{tab:results} also show the advantage
of the \symtxt{} algorithm over the \gsetxt{} and L\# algorithms, each of
which performs case-splitting during the analysis.
The number of paths explored by the \symtxt{} algorithm is strictly 
less than or equal to the number
of paths explored by \gsetxt{} for all artifacts. As a result,
fewer test cases will be generated to achieve the same control-flow 
path coverage when compared to GSE and Lazier\#.

%In summary, the benefits of avoiding
%initialization-based non-determinism outweigh the increased
%complexity in the constraints due to the advances made in SMT
%solvers in these examples. In fact, the \symtxt{} algorithm can analyze certain types of programs with
%orders of magnitude greater efficiency than with \gsetxt{} or
%Lazier\#, while covering exactly the same control flow paths. 

%We can use this
%result to do more efficient test case generation. From a path
%generated we can use the solutions provided by the constraint solver
%to instantiate a set of concrete heaps to provide as test input. 


%Interestingly, \symtxt{} path growth appears
%to be sub-exponential in $k$ for the LinkedList program.




%The additional states generated by summary heap are unsatisfiable
%which is why they do not add nodes in the final symbolic execution
%tree. Furthermore, the larger state count does not impact the overall
%runtime of the technique.

% Despite this, in practice this is often mitigated by the
%fact that \symtxt{} can dispatch address compares without consulting
%the constraint solver.


