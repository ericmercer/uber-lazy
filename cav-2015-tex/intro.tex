\section{Introduction}

% SymExe is cool because for reasons x,y, and z

In recent years symbolic execution has provided the basis for various
software testing and analysis techniques. Symbolic execution
systematically explores the program execution space represeing input values symbolically, 
and for each explored path, it computes constraints on the
symbolic inputs to create a \emph{ path condition}.  Path
conditions computed by symbolic execution characterize the observed
program execution behaviors and have been used as an enabling
technology for various applications, e.g., regression
analysis~\cite{backes:2012,Godefroid:SAS11,Person:FSE08,person:pldi2011,Ramos:2011,Yang:ISSTA12},
data structure repair~\cite{KhurshidETAL05RepairingStructurally},
dynamic discovery of
invariants~\cite{CsallnerETAL08DySy,Zhang:ISSTA14}, and
debugging~\cite{Ma:2011}.

%
A major reason that path conditions are so useful is that each one represents exactly the set of concrete program inputs that would result in a given execution path. For any given program, a concrete execution will follow the same path as a symbolic execution if and only if the concrete inputs satisfy the path condition. Furthermore, because path conditions are logical predicates, they allow precise reasoning over potentially unbounded sets of program inputs. 

Symbolic execution's reliance on path conditions is both it's greatest strength, and a significant challenge. Since the path condition must be encoded in the form of an SMT problem, symbolic execution is limited by the capabilities of the underlying constraint solver. If the solver does not include a theory for reasoning about a given program operation, then the symbolic execution cannot proceed. Thus, extending the capabilities of symbolic execution to reason about new theories is an area of active research. 

A primary interest in the research is how to dereference symbolic
input references in an unknown heap. Despite the many proposed solutions for reasoning
about symbolic input references and heaps (ADD CITATIONSS), to date, none has
been able to preserve symbolic execution's most desirable property:
the ability to produce a path condition that exactly represents all
possible input heaps for a given execution path.

% A couple of symExe’s big problems are path explosion and references. 

%Two of the main challenges facing current symbolic execution techniques 
%are path explosion and programs accepting references as inputs~\cite{Qu:2011,Chen:2013}.
% The path explosion problem stems from the way that 
%symbolic execution explores a program execution on a per-path basis. For 
%those programs for which there is an exponential number of possible 
%program paths, symbolic execution can be extremely inefficient. 
%References are a problem because symbolic execution requires that the 
%program state be represented by predicates formulated in terms of the 
%program inputs. Formulating such predicates for referencing operations 
%over potentially unbounded inputs has until now remained an open 
%question. 


% You can solve dereferencing by concretization, but that’s incomplete. 
%Here is an example of why this stinks.
One possible way to cope with the reference problem is to use a technique 
known as dynamic symbolic execution (DSE). When a DSE tool encounters 
an operation that is beyond the capabilities of its associated constraint 
solvers, such as dereferencing a symbolic reference, it substitutes a valid 
concrete result in place of the symbolic expression. However, this process 
of concretization introduces approximation into the formerly exact path condition,
and may even cause the analysis to miss valid program behaviors. 

%\begin{figure}
%void example( container a,b,c,d,x,y){
%a.f = x;
%b.f = c;
%c.f = d;
%d.f = a;
%if(x.f == y.f.f)
%     abort();\\error!
%}
%\caption{completeness example}
%\label{fig:DSEtest}
%\end{figure}
%
%Consider the example in \ref{fig:DSEtest}. During DSE, both symbolic and 
%concrete executions occur in parallel. Suppose that for the first pass, the 
%concrete execution picks the following points-to relationships: $a\rightarrow 
%loc_a, b\rightarrow loc_b, c\rightarrow loc_c, d\rightarrow loc_d ,x
%\rightarrow loc_a,  y\rightarrow loc_b$. When the program reaches the if() 
%statement, symbolic dereferencing of x and y are required. In order to 
%dereference symbol x to get x.f, x is concretized to point to $loc_a$, and 
%symbol x from field f is returned. Dereferencing y to find y.f requires 
%concretizing y to point to $loc_b$, From there, dereferencing b.f gives us 
%the reference d as the final value for y.f.f . Assuming the “false" branch is 
%executed first, the branch condition (x.f != y.f.f) reduces to x!=d, which 
%evaluates to “true" and DSE proceeds until program termination.
%After following the false branch, DSE will attempt to follow the true branch, 
%but the branch condition x==d will evaluate to false, and so DSE will 
%attempt a second pass starting from the beginning with a modified path 
%condition. For the second pass, DSE adds x==d to the path condition from 
%the beginning, to try to get the “true” branch. This time, the concrete 
%execution will choose x to point to $loc_d$. When evaluating the branch 
%condition, x.f will evaluate to a. Since the value for y is unchanged, the read 
%from y.f.f evaluates to d. The branch condition reduces to a==d, which 
%evaluates to false, so the “true” branch cannot be followed. In this instance, 
%DSE will fail to find a path to the error condition. 

% You can model references by forking the system state, but that makes 
%path explosion worse.
An alternative to concretization is to construct the input heap in a lazy manner,
deferring materialization of objects on the concrete heap until they
are needed for the analysis to proceed. The materialization creates
additional non-deterministic choice points in the symbolic execution
tree by representing the feasible heap configurations as (i) null,
(ii) an instance of a new reference of a compatible class, and (iii)
an alias to a previously initialized symbolic reference.  Symbolic
execution then follows concrete program semantics for materialized
heap locations. Although this approach enables the analysis of heap
manipulating programs, a large number of feasible concrete heap
configurations are created. \emph{Since each configuration requires a separate
path} (what does this mean), GSE induces a path explosion problem while at the 
same time splitting the symbolic input space and decreasing the 
utility of the path condition. (The last sentence is difficult to undersatnd. Consdier a rewrite).

%Attempt to argue for completeness:
In searching for a solution to the path explosion problem, it is tempting to consider one of the several techniques developed for representing multiple heap shapes within a single predicate. However, in contrast to GSE, these techniques tend to impose constraints on the symbolic input heap. These constraints extend to the path condition, such that it no longer forms a complete representation of all possible input heaps.

A common constraint is a requirement to specify some arbitrary bound before starting the analysis. For example, the analysis might require that the maximum number of nodes in the heap be specified. This creates a problem, because it's difficult to determine beforehand the right bound to set to ensure completeness, and the analysis may provide no completeness information upon termination. Other limitations prevalent with summary-type heap representations include prohibiting recursive data structures, data structures with loops, or disallowing any type of aliasing whatsoever.

Since these constraints are frequently built in to the core of the underlying representation, it is not often obvious how to remove them. For example, methods that require setting bounds on the node count are usually predicated on a fixed address space model. In a fixed model, symbolic pointer dereferencing is accomplished by first conducting a search for potential aliases of compatible type, then producing an expression based on that set of aliases. Since number of terms in the expression depends on the size of the address space, it seems that dereferencing a pointer in a space with an unbounded number of aliases would require an expression with an unbounded number of terms.

% You can solve path explosion by bounding the execution and rolling 
%everything into one big equation, but then you’re incomplete. Here is an 
%example why that stinks.
%-maybe point out that finding the right bounds is a hard problem
%One solution to the path explosion problem is to model the input heap as a 
%predicate over a bounded set of locations. This allows the analysis to 
%maintain a single representation for a set of possible heap configurations 
%on each execution path, without case splitting for dereferencing operations. 
%However, by placing an arbitrary bounds on the size of the input heap, neither
%the path condition, nor the analysis performed by these techniques is complete.

% This paper introduces a technique that is, to the best knowledge of the 
%authors, the first sound and complete heap for SymEXE
This paper introduces a technique for modeling references and their
associated operations that is sound and complete with respect to the
properties provable by symbolic execution. The technique captures in a
summary representation all heaps that follow a specific program path
up to a given point of execution. To the knowledge of the authors, it
is the first technique to do so.

The technique begins with the notion of an unconstrained input
heap. As a symblic integer represents all integers at the beginning of
execution, so does the symbolic input heap.

THIS NEXT BIT STILL NEEDS SOME WORK:

% Creating this technique required the following key insights:
These advances were enabled by the following key insights: 

First, that a complete analysis requires an unconstrained input heap. 
However, it is unclear from prior work how this might be accomplished.

Second, that GSE techniques needlessly split during dereferencing 
operations. If GSE was performing a concretization, as in DSE, then case 
splitting makes more sense. However, lazy initialization is not a 
concretization, and is in fact only a partitioning of the input space. 

Third, that we can combine lazy initialization with a compositional heap 
abstraction to form constraints on a potentially unbounded input heap.


% This paper makes the following contributions.


\noindent{This paper makes the following contributions:}

\begin{compactdesc}

\item\textbf{-} The first sound and complete system for reasoning symbolically about the 
set of input heaps along any valid program path. 

\item\textbf{-} A bisimulation proof establishing the soundness and 
completeness of the heap summary approach with respect to
properties provable by GSE.

\item\textbf{-} A proof-of-concept implementation and empirical study 
demonstrating the scalability of the summary heap approach
compared to other GSE approaches.

\end{compactdesc}


%Initial work on symbolic execution largely focused on checking
%properties of programs with primitive
%types~\cite{clarke76TSE,King:76}.  With the advent of object-oriented
%languages, recent work has generalized the core ideas of symbolic
%execution to enable analysis of programs containing complex data
%structures with unbounded domains, i.e., data stored on the
%heap~\cite{Kiasan06,Kiasan07,GSE03}.  These \emph{Generalized 
%Symbolic
%  Execution} (GSE) techniques construct the heap in a lazy manner,..

%The goal of this work is to mitigate the path explosion problem in GSE
%by grouping multiple heaps together and only partitioning the heaps at
%points of divergence in the control flow graph. Our inspiration is
%found in the domain of static analysis that uses sets of constraints
%over heap locations to encode multiple heaps in a single
%representation. These sets, sometimes known as \emph{value sets} or
%\emph{value summaries}, allow multiple heaps to be represented
%simultaneously with a higher degree of precision than afforded by
%traditional techniques for shape analysis. Some of these previous
%attempts, however, are unable to handle aliasing in heaps due to a
%recursive definition of objects~\cite{Xie:2005}, while others require
%a set of heaps as input and are unable to initialize heaps
%on-the-fly~\cite{Dillig:2011,Tillmann:2008}.  As is typical in static
%analysis, over approximation of the heap representations alleviates
%some of these limitations but often leads to infeasible heaps. Also,
%most static analysis techniques for heap updates require a rewrite of
%the constraint system making it prohibitive for use in the context of
%symbolic execution.

%In this work, to effectively represent multiple heaps simultaneously
%in the context of symbolic execution, we define a novel heap
%representation and an algorithm to initialize and update the heap
%on-the-fly. In essence, our summary heap approach supports aliasing,
%does not require constraint rewriting on heap updates, and reduces
%non-determinism in the search space during symbolic execution.
%
%We represent the heap as a bipartite graph consisting of references
%and locations. Each reference is able to point to multiple locations,
%where each edge is predicated on constraints over aliasing between
%references. Each location points to a single reference for a given
%field. The use of a bipartite graph affords two key advantages: (i) it
%allows for a non-recursive definition of objects which enables us to
%support aliasing, and (ii) it does not introduce auxiliary variables
%or require rewriting of non-local constraints during updates to the
%heap.
%
%The summary heap algorithm defines how the bipartite graph is updated
%during lazy initialization. Unlike GSE, however, the summary heap
%algorithm introduces non-determinism in the search only at points of
%divergence in the control flow graph. These points of non-determinism
%are at field accesses that lead to null-pointer exceptions and at
%comparisons of references. The former represents a divergence due to
%exceptional control flow while the latter is due to program structure.
%The combination of the heap representation and the summary heap
%algorithm enables us to improve the efficiency of symbolic execution
%of heap manipulating programs over state-of-the-art techniques.
%
%The summary heap algorithm is sound and complete with respect to
%properties that are provable using GSE. This proof is accomplished by
%showing the existence of a bisimulation between states in GSE and
%states in the summary heap algorithm.  A preliminary implementation in
%Java Pathfinder (JPF) shows that in general, the heap summary
%algorithm improves over other state-of-the-art techniques, and in some
%instances, the improvement is remarkable: two-orders of magnitude
%reduction in running time. More importantly though, the heap summary
%enables the initialization of larger more complex heaps than
%previously possible as shown in our results.

