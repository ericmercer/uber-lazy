\section{Generalized Symbolic Execution with Lazy Initialization}
Generalized symbolic execution with lazy initialization is a technique
to apply symbolic execution to non-primitive data types (i.e.,
objects) \cite{GSE03}. The approach initializes each symbolic object
to be either null, a new instance of the object, or an alias to an
object previously created as part of lazy initialization. Each of
these outcomes is a possible choice, and a model checker is able to
exhaustively enumerates these choices effectively creating all
possible concrete heaps under the choice sets. The approach is first formalized in this section and then extended to describe the precise heap summaries.


Many of these concrete
heaps explore redundant control flow paths in the program under test,
but since symbolic model checking is stateless, subject to a bound to
terminate the search, the model checker needlessly explores many
redundant state leading to severe state explosion.


\figref{fig:surface-syntax} defines the surface syntax for the
Javalite language \cite{saints-MS}. \figref{fig:machine-syntax} is
the machine syntax. Javalite is syntactic machine
defined as rewrites on a string. The semantics use a CEKS model with a (C)ontrol string representing the expression being
evaluated, an (E)nvironment for local variables, a (K)ontinuation for
what is to be executed next, and a (S)tore for the heap. 

\input{surface-syntax}
\input{machine-syntax}

%\item $n$ are numbers, and the set of all positive natural numbers is $\mathbb{N}^+$.
The heap is a labeled bipartite graph consisting of references $R$ and
locations $L$ in the store. The functions $R$ and $L$ are defined for convenience
in manipulating the labeled bipartite graph.
\begin{itemize}
\item $R(l,f)$ maps location-field pairs from the store to a reference in $R$; and
\item $L(r)$ maps references to a set of location-constraint pairs in the store.
\end{itemize}
A reference is a node that gathers the possible store locations for an
object during symbolic execution. Each store location is guarded by a
constraint that determines the aliasing in the heap. Intuitively, the
reference is a level of indirection between a variable and the store,
and the reference is used to group a set of possible store locations
each predicated on the possible aliasing in the associated constraint.
For a variable (or field) to access any particular store location
associated with its reference, the corresponding constraint must be
satisfied.

Locations are boxes in the graphical representation and indicated with
the letter $l$ in the math. References are circles in the graphical
representation and indicated with the letter $\cfgnt{r}$ in the
math. The special symbol $\bot$ is an uninitialized reference. Edges
from locations are labeled with field names $\cfgnt{f}$. Edges from
the references are labeled with constraints $\phi \in \Phi$ (it is
assumed that $\Phi$ is a power set over individual constraints and
$\phi$ is a set of constraints for the edge).

The function $\mathbb{VS}(L,R,\phi_g,r,f)$ constructs the value-set given a
heap, reference, and desired field:
\[
\begin{array}{rcl}
  \mathbb{VS}(L,R,\phi_g,r,f) & = & \{(l^\prime\ \phi\wedge\phi^\prime) \mid \\
  & & \ \ \ \ \exists l\ ((l\ \phi) \in L(r)\ \wedge \\
  & & \ \ \ \ \ \ \ \ \exists r^\prime \in R(l,f) ( \\
  & & \ \ \ \ \ \ \ \ \ \ \ \ (l^\prime\ \phi^\prime) \in L(r^\prime)\ \wedge\\
  & & \ \ \ \ \ \ \ \ \ \ \ \ \mathbb{S}(\phi\wedge\phi^\prime\wedge \phi_g)))\}
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is satisfiable.

The strengthen function $\mathbb{ST}(L,r,\phi^\prime)$ strengthens every
constraint from the reference $r$ with $\phi^\prime$ and keeps only location-constraint
pairs that are satisfiable after this strengthening:
\[
\begin{array}{rcl} 
\mathbb{ST}(L,r,\phi^\prime) & = & \{ (l\ \phi\wedge\phi^\prime) \mid 
(l\ \phi)\in L(r)\wedge\mathbb{S}(\phi\wedge\phi^\prime) \}
\end{array}
\]

\input{javalite-common}
\input{initialize-lazy}
\input{lazy}
\input{summarize-precise}
\input{precise}
