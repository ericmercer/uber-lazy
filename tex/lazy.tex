\section{GSE with Lazy Initialization}

A special reference, $\cfgnt{r}_\mathit{un}$, and location,
$\cfgnt{l}_\mathit{un}$, is introduced to support lazy initialization
in GSE. The '$\mathit{un}$' is to indicate the reference or location
is uninitialized at the point of execution. The initial state of the
machine maps $\cfgnt{r}_\mathit{null}$ as before and adds
$\cfgnt{L}(\cfgnt{r}_\mathit{un}) = \{(\cfgt{true}\ \cfgnt{l}_\mathit{un})\}$

A field in an object is symbolic, meaning it is uninitialized, if the
location for the field is $\cfgnt{l}_\mathit{un}$ on some constraint. The function
$\mathbb{UN}(\cfgnt{L}, \cfgnt{R}, \cfgnt{r}, \cfgnt{f}) =
\{\cfgnt{l}\ ...\}$ returns constraint-location pairs in which the field $\cfgnt{f}$
is uninitialized:
\[
\begin{array}{rcl}
\mathbb{UN}(\cfgnt{L}, \cfgnt{R}, \cfgnt{r}, \cfgnt{f}) & = &\{ \lp\phi\ \cfgnt{l}\rp \mid \lp \phi\ \cfgnt{l}\rp  \in \cfgnt{L}\lp \cfgnt{r}\rp  \wedge \\
& & \ \ \ \ \exists \phi^\prime \lp \lp \phi^\prime\ \cfgnt{l}_\mathit{un}\rp  \in \cfgnt{L}\lp \cfgnt{R}\lp l,\cfgnt{f}\rp\rp \wedge \\
& & \ \ \ \ \ \ \ \ \mathbb{S}\lp \phi \wedge \phi^\prime \rp\rp\}\\
\end{array}
\]
where $\mathbb{S}(\phi)$ returns true if $\phi$ is satisfiable. The
cardinality of the set is never greater than one in GSE and the
constraint is always satisfiable because all constraints are
constant. This property is relaxed in GSE with heap summaries.

\input{initialize-lazy}
\input{lazy-fig}

\begin{comment}
NOT SURE THIS NEEDS TO BE HERE ANYMORE
Generalized symbolic execution with lazy initialization is a technique
to apply symbolic execution to non-primitive data types (i.e.,
objects) \cite{GSE03}. The approach initializes each symbolic object
to be either null, a new instance of the object, or an alias to an
object previously created as part of lazy initialization. Each of
these outcomes is a possible choice, and a model checker is able to
exhaustively enumerates these choices effectively creating all
possible concrete heaps under the choice sets. The approach is first
formalized in this section and then extended to describe the precise
heap summaries.


Many of these concrete
heaps explore redundant control flow paths in the program under test,
but since symbolic model checking is stateless, subject to a bound to
terminate the search, the model checker needlessly explores many
redundant state leading to severe state explosion.

A reference is a node that gathers the possible store locations for an
object during symbolic execution. Each store location is guarded by a
constraint that sets the conditions under which the edge is valid. Intuitively, the
reference is a level of indirection between a variable and the store,
and the reference is used to group a set of possible store locations
each predicated on the possible aliasing in the associated constraint.
For a variable (or field) to access any particular store location
associated with its reference, the corresponding constraint must be
satisfied.

Locations are boxes in the graphical representation and indicated with
the letter $l$ in the math. References are circles in the graphical
representation and indicated with the letter $\cfgnt{r}$ in the
math. The special symbol $\bot$ is an uninitialized reference. Edges
from locations are labeled with field names $\cfgnt{f}$. Edges from
the references are labeled with constraints $\phi \in \Phi$ (it is
assumed that $\Phi$ is a power set over individual constraints and
$\phi$ is a set of constraints for the edge).
\end{comment}
